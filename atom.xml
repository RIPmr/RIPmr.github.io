<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>HU ANIME</title>
    <updated>2023-01-20T11:49:41.616Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <subtitle>会画画的程序猿</subtitle>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2023, HU ANIME</rights>
    <entry>
        <title type="html"><![CDATA[[Tuto] 无标记单目摄像头实时表情动捕 - 细节增强]]></title>
        <id>http://localhost:4000/post/TUTO-MEPS-P2/</id>
        <link href="http://localhost:4000/post/TUTO-MEPS-P2/">
        </link>
        <updated>2023-01-20T10:01:38.000Z</updated>
        <summary type="html"><![CDATA[<pre><code>直接使用前文中完成的MEPS版本进行动捕，我们会发现输出动画的抖动十分严重且缺乏细节。本篇我们基于多源数据增强MEPS的动捕细节表现及稳定性。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code>直接使用前文中完成的MEPS版本进行动捕，我们会发现输出动画的抖动十分严重且缺乏细节。本篇我们基于多源数据增强MEPS的动捕细节表现及稳定性。
</code></pre>
<!-- more -->
<h2 id="meps-markless-facial-tracking-and-expression-projection-using-single-rgb-webcam">MEPS: Markless facial tracking and expression projection using single RGB WebCam</h2>
<hr>
<h3 id="part-e-detail-enhancement-time-spatial-optimizations">Part E – Detail Enhancement &amp; Time Spatial Optimizations</h3>
<h4 id="e-1-时空表情动画平滑-time-spatial-facial-animation-filter">E-1 时空表情动画平滑 / Time Spatial Facial Animation Filter</h4>
<p>直接使用上一节中完成的MEPS版本进行动捕，我们会发现输出动画的抖动十分严重，尤其是眼睛部位。造成抖动的因素有很多，比如直接使用2D landmarks坐标点计算眼睛的闭合百分比、摄像头的分辨率不足等。</p>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1674212657706.gif" alt="" loading="lazy"></figure>
<p>除了提高摄像头设备的分辨率、将Landmarks坐标转换为3D再进行计算之外，我们还可以通过时空间平滑进一步改善动捕动画的质量。</p>
<p>就像光栅化渲染管线中做TAA一样，我们可以在Receiver模块维护一个动态的滑动窗口，对动捕数据做一个时空间序列上的高斯滤波。MEPS的实际实现中使用一个大小为12的窗口，执行平滑操作时取左边一半的2D高斯核进行计算。</p>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1674212671782.png" alt="" loading="lazy"></figure>
<p>下图为执行时空间平滑前后的动捕数据对比，我们在一个完整的眨眼周期内按相同的时间间隔采样10次，分别记录左眼与右眼的闭合百分比。闭合百分比范围为0-100，0代表眼睛完全张开，100代表眼睛完全闭合。</p>
<p>从数据中可以看到平滑后的眨眼动画抖动问题得到了极大改善，同样的处理方法也可以沿用到嘴部等其他部位。</p>
<figure data-type="image" tabindex="3"><img src="http://localhost:4000/post-images/1674212694462.gif" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="http://localhost:4000/post-images/1674212688383.png" alt="" loading="lazy"></figure>
<h4 id="e-2-音频数据融合-audio-based-facial-animation-enhancement">E-2 音频数据融合 / Audio based Facial Animation Enhancement</h4>
<p>借鉴faceware中的处理方式，我们这里也可以通过增加音频信息的方式，帮助MEPS在捕捉演员的对话表演时得到更完美的口型动画。</p>
<p>我们可以简单地仅处理a,e,i,o,u几个元音音节，也可以根据中文发音的特性多补充一些连读音节得到更精细的动画效果。现成的音频分析库有很多，MEPS中使用的是Microsoft推出的SAPI语音引擎，SAPI可以转换人类的声音语音流到可读的文本字符串或者文件。SAPI的详细使用流程就不在这里赘述了，大家感兴趣可以自行到Microsoft官网去查阅手册。</p>
<p>最后我们通过“置信度”对从视频流中得到的动捕口型与从语音中得到的音节口型做混合，得到最终的口型动画输出。混合过程如下式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>i</mi><mi>p</mi><mi>A</mi><mi>n</mi><mi>i</mi><mi>m</mi><mrow><mo fence="true">(</mo><mi>t</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>m</mi><mi>i</mi><mi>x</mi><mrow><mo fence="true">(</mo><mrow><mi>v</mi><mi>A</mi><mrow><mo fence="true">(</mo><mi>t</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mtext>  </mtext><mi>a</mi><mi>A</mi><mrow><mo fence="true">(</mo><mi>t</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>c</mi><mrow><mo fence="true">(</mo><mi>t</mi><mo fence="true">)</mo></mrow></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">LipAnim\left( t \right) = mix\left( {vA\left( t \right),\;aA\left( t \right),c\left( t \right)} \right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">A</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mrow><mo fence="true">(</mo><mi>t</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>m</mi><mi>i</mi><mi>x</mi><mrow><mo fence="true">(</mo><mrow><mi>c</mi><mrow><mo fence="true">(</mo><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>max</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mrow><mn>0.5</mn><mo separator="true">,</mo><mfrac><mrow><mo fence="true">∣</mo><mrow><mi>v</mi><msup><mi>A</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mrow><mo fence="true">(</mo><mi>t</mi><mo fence="true">)</mo></mrow></mrow><mo fence="true">∣</mo></mrow><msup><mrow><mo fence="true">(</mo><mrow><mn>1</mn><mo>+</mo><mi>v</mi><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup><msup><mrow><mo fence="true">(</mo><mi>t</mi><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><mo fence="true">)</mo></mrow><mfrac><mn>3</mn><mn>2</mn></mfrac></msup></mfrac></mrow><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mn>0.75</mn></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">c\left( t \right) = mix\left( {c\left( {t - 1} \right),\max \left( {0.5,\frac{{\left| {vA&#x27;&#x27;\left( t \right)} \right|}}{{{{\left( {1 + vA&#x27;{{\left( t \right)}^2}} \right)}^{\frac{3}{2}}}}}} \right),0.75} \right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.383965em;vertical-align:-2.03394em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.3500249999999996em;"><span style="top:-1.9499950000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-3.1050050000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.350025em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.850025em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.3500249999999996em;"><span style="top:-1.9499950000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-3.1050050000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.350025em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.850025em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.428892em;"><span style="top:-2.1100000000000003em;"><span class="pstrut" style="height:3.49392em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord"><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6778919999999999em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.49392em;"><span style="top:-3.9029em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.72392em;"><span class="pstrut" style="height:3.49392em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.170920000000001em;"><span class="pstrut" style="height:3.49392em;"></span><span class="mord"><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.03394em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.3500249999999996em;"><span style="top:-1.9499950000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-3.1050050000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.350025em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.850025em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mord">5</span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.3500249999999996em;"><span style="top:-1.9499950000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-3.1050050000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.350025em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.850025em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中<em>LipAnim(t)<em>为</em>t</em>时刻下的口型动画输出，<em>vA</em>为视频动捕口型动画曲线，<em>aA</em>为音频口型动画曲线；<em>c</em>为置信度，其主要考虑<em>vA</em>在<em>t</em>时刻下平整程度，如果平整度较低，说明此时视频动捕结果比较noisy，于是我们就在输出结果中更多地混合来自音频的动画曲线。</p>
<figure data-type="image" tabindex="5"><img src="http://localhost:4000/post-images/1674212756128.gif" alt="" loading="lazy"></figure>
<h4 id="e-3-细节增强-facial-animation-detail-enhancement">E-3 细节增强 / Facial Animation Detail Enhancement</h4>
<p>MEPS的实现终于来到了最后一部分，last but not least，这部分细节增强的实现对最终输出的动画效果来说是至关重要的一部分。由于MEPS中使用的输入设备仅仅是没有深度信息的低分辨率单目RGB摄像头，所以学界现在比较流程的去重构3D Face Mesh[10-12, 16]得到皱纹纹理[13, 14]的流程是行不通的。通过单目RGB只能重构出非常粗糙且丢失了高频细节的面部网格，虽然可以直接基于RGB图像恢复面部法线，但质量是无法达到产品级需求的，更何况我们使用的还仅仅只是一个640P的摄像头。</p>
<p>MEPS中我们另辟蹊径，采用的表情细节增强方法来自于Beeler T等人于14年在TOG上提出的Facial Performance Enhancement Using Dynamic Shape Space Analysis [18]一文。这篇Paper中将面部面部动捕流程和面部动画细节分离，建立一个高频细节数据库，在演员表演动捕得到粗糙表情动画的基础上，叠加高频细节，还原动捕演员的表演细节例如人脸在动态过程中产生的细小皱纹、面部不同部位之间由于动态的碰撞挤压产生的堆积效应等。整个系统流程如下图所示。</p>
<figure data-type="image" tabindex="6"><img src="http://localhost:4000/post-images/1674212780060.png" alt="" loading="lazy"></figure>
<p>整个流程可以划分为四个大步骤：<strong>Pre-Processing</strong>、<strong>Performance data input</strong>、<strong>Shape spatial enhancement</strong>以及<strong>Time spatial enhancement</strong>。</p>
<p>Pre-Processing阶段基于多视角摄影机扫描演员面部得到高模，利用拉普拉斯平滑（Laplacian smoothing）算法分离高频细节，建立数据库。</p>
<figure data-type="image" tabindex="7"><img src="http://localhost:4000/post-images/1674212804069.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="http://localhost:4000/post-images/1674212807157.png" alt="" loading="lazy"></figure>
<p>由于扫描得到的数据库中的细节向量顶点非常密集，逐一计算性能压力太大，于是接着Beeler T等人会对面部mesh的顶点进行分簇，以每一个簇作为独立向量对数据库中的特征向量进行压缩。</p>
<figure data-type="image" tabindex="9"><img src="http://localhost:4000/post-images/1674212813190.png" alt="" loading="lazy"></figure>
<p>Performance data input阶段是常规的演员表演动捕阶段，得到一个毫无细节的动捕动画即可。重点是在Shape spatial enhancement阶段，我们要根据输入的动捕动画匹配数据库中的对应状态位置，然后将数据库中的静态表演细节映射到动捕动画上，得到高细节的表情动画输出。</p>
<p>数据库中高频细节的匹配是基于最小二乘法（Least-Square Method）对特征向量做匹配实现的：</p>
<center><img src="../../post-images/1674212822159.png" width="350" /></center>
<p>当然了，由于每一个时刻下单帧表情中同一张脸上的不同簇可能会映射到不同的数据库细节数据上，如下图中眉心和额头混合了两组不同的细节数据：</p>
<figure data-type="image" tabindex="10"><img src="http://localhost:4000/post-images/1674212854448.png" alt="" loading="lazy"></figure>
<p>不同部位的高频数据直接叠加可能会出现接缝、不平整等一系列问题，于是Beeler T等人还会在输出最终的表情动画前对混合结果再做一次平滑处理。下图中间一列是直接混合高频细节的结果，可以看到嘴角部分十分明显的接缝；右侧一列是平滑后的混合结果。</p>
<figure data-type="image" tabindex="11"><img src="http://localhost:4000/post-images/1674212869734.png" alt="" loading="lazy"></figure>
<p>MEPS中借鉴了这篇Paper中的<strong>Shape spatial enhancement</strong>部分，我们首先也建立一个高频细节数据库，数据库中手动制作常用表情的高频细节blend mesh，然后使用和论文中一样的方法，根据视频动捕输入，寻找对应的各个部分的细节，进行动态叠加与平滑，得到最终的高质量动画输出。</p>
<figure data-type="image" tabindex="12"><img src="http://localhost:4000/post-images/1674212892727.png" alt="" loading="lazy"></figure>
<p>上图为MEPS测试中使用的角色模型绑定以及表情细节数据库，下图分别为细节增强前后的动捕动画输出以及增加纹理贴图之后的带表情动画角色渲染结果。</p>
<figure data-type="image" tabindex="13"><img src="http://localhost:4000/post-images/1674212906961.gif" alt="" loading="lazy"></figure>
<center>图中左侧为原始动捕结果，右侧为细节增强后的结果</center>
<figure data-type="image" tabindex="14"><img src="http://localhost:4000/post-images/1674212937411.png" alt="" loading="lazy"></figure>
<center>最后为模型添加纹理，得到最终的渲染输出</center>
<h3 id="conclusion">Conclusion</h3>
<p>MEPS是我个人近期做的一次自我感觉较好的业余实践，从CG到网络、从ML到视觉、从Web端到DCC端，是一个综合性很强的课题，对自己来说各个方面都是一次挑战与检验。本文记录一下MEPS实现过程中的一些方法领悟，希望能给读到本文的小伙伴一些启示。</p>
<p>MEPS所需硬件成本极低，可扩展性强，能够快速接入各种DCC软件或游戏引擎，可以帮助小型工作室和个人开发者快速构建自己的表情动画工作流，提升开发效率，节约成本，并得到质量还算可以接受的表情动画。</p>
<p>硬件方面，我们全程只使用了一个分辨率仅640p的网络摄像头，成本不到30元。以一顿饭钱的超低价格完成了中高质量的产品级表情动捕。</p>
<p>最后感谢看到这里的小伙伴，祝你新年快乐！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Tuto] 无标记单目摄像头实时表情动捕 - 基础实现]]></title>
        <id>http://localhost:4000/post/TUTO-MEPS-P1/</id>
        <link href="http://localhost:4000/post/TUTO-MEPS-P1/">
        </link>
        <updated>2022-10-01T14:21:41.000Z</updated>
        <summary type="html"><![CDATA[<pre><code>本文提出一种无标记的低成本表情动捕方案，仅基于低分辨率的单目网络摄像头实现中高质量的表情动捕
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code>本文提出一种无标记的低成本表情动捕方案，仅基于低分辨率的单目网络摄像头实现中高质量的表情动捕
</code></pre>
<!-- more -->
<h2 id="meps-markless-facial-tracking-and-expression-projection-using-single-rgb-webcam">MEPS: Markless facial tracking and expression projection using single RGB WebCam</h2>
<hr>
<p>随着图形技术的成熟，表情动捕方法越来越多，但高精度设备动辄几个W的价格让个人创作者和小型开发团队望而却步。而且这些设备往往重量可观，非专业动捕演员戴在头上可能就只剩下“痛苦”的表情。有些动捕方案还需要在脸上画上标记点，使用十分不便。因此本文提出一种无标记的低成本表情动捕方案，仅基于低分辨率的单目网络摄像头实现中高质量的表情动捕。</p>
<h3 id="part-a-brief-history-of-markless-facial-tracking">Part A – Brief History of Markless Facial Tracking</h3>
<p>先来看看专业的面捕设备长什么样，下图是《最终幻想：王者之剑》CG电影表情动捕现场。专业设备虽然能够实现质量极高的表情捕捉，但这比头还大的设备是不是看上去就很费劲。</p>
<center><img src="../../post-images/1674202770703.png"/></center>
<p>于是各种轻量化的设备开始出现，同时都在朝着去掉脸上标记点的方向努力，但此时依然没有摆脱头戴式设备的局限。</p>
<center><img src="../../post-images/1674204115965.png" width="350" /></center>
<p>直到2012年faceshift studio横空出世，彻底改变了现状，这是一套真正没有沉重头戴式设备、无标记、使用方便且动捕质量达标的解决方案。<br>
Faceshift到底用了什么黑魔法？faceshift面捕方案的核心是借助深度相机实现用户的表情输入，也正是得益于微软Kinect等一众消费级深度相机的推出，使用faceshift，意味着你可以仅依靠下图中任意一款深度相机设备实现表情动捕。</p>
<center><img src="../../post-images/1674204162575.png" width="250" /></center>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1674204166312.png" alt="" loading="lazy"></figure>
<p>GDC2015上，faceshift studio展示了他们强大的无标记面捕解决方案，不论写实风还是卡通风，甚至是从人到动物，faceshift都能轻松驾驭。</p>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1674204193057.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="http://localhost:4000/post-images/1674204195942.png" alt="" loading="lazy"></figure>
<p>到这里，可能有同学觉得问题已经解决了，因为现在深度相机的价格不算昂贵，比如kinect的市场价在千元左右，个人开发者也能够接受。但不要忘了除了深度相机，你还需要一个faceshift studio才能开始你的表演。而faceshift studio的授权价格为一年1500美元。<br>
时间继续往前走，2015年，突然CG界一个惊人的消息传出，震惊了手机界：Apple收购了faceshift，没错，就是做出你拿在手上的那个iPhone的Apple。</p>
<figure data-type="image" tabindex="4"><img src="http://localhost:4000/post-images/1674204225426.png" alt="" loading="lazy"></figure>
<center>听到这个消息的时候，我的表情和图上是完全一致的</center>
<br>
<p>于是faceshift的技术被整合到iPhone，有了后来大家所熟知的Animoji功能。但如果iPhone的面捕就仅仅是Animoji这么简单，这里就不会提到iPhone了。Apple的野心显然不止于此，因为iPhone的ARKit动捕数据是可以导出的！比如说可以像下图中一样，将动捕数据导出到Unity3D，直接驱动三维角色的表情动画。</p>
<figure data-type="image" tabindex="5"><img src="http://localhost:4000/post-images/1674204411919.gif" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="http://localhost:4000/post-images/1674204415452.gif" alt="" loading="lazy"></figure>
<p>更绝的还不止于此，Apple打得一手推销iPhone的好牌：在iPhone中做面捕和导出动捕数据是不需要经过faceshift studio的，这相比于购买一台depth camera + faceshift studio license的价格显然是要低得多，以至于后来在国产独立游戏《光明记忆：无限》中，作者直接使用iPhone作为主角舒雅的面捕设备。</p>
<figure data-type="image" tabindex="7"><img src="http://localhost:4000/post-images/1674204452632.jpg" alt="" loading="lazy"></figure>
<center>《光明记忆：无限》游戏开发者曾贤成认为：</center>
<center>善用科技技术与软体工具，可节省大量花在游戏角色的开发与动画的时间与费用</center>
<br>
<p>但显然iPhone的价格对于本文作者来说还是有点高（狗头。要是能有这样一套方案：直接基于价格低廉随处可见的网络摄像头进行动捕，岂不完美？<br>
2017年实时三维动画软件iClone 7发布，其集成的混合式表情动捕方案Faceware能够实现基于网络摄像头及语音输入的无标记动捕，结合iClone自身强大的虚拟人创建能力，一套工作流直接打通了三维角色动画的“任督二脉”，提供了从捏人到绑定再到动画捕捉的全自动一站式流程，实力可谓非常恐怖。</p>
<figure data-type="image" tabindex="8"><img src="http://localhost:4000/post-images/1674204509722.png" alt="" loading="lazy"></figure>
<p>但问题同样还是出在钱包上，iClone单独的授权费就高达<strong>199刀</strong>，faceware的授权还是独立的，不仅如此，许多其他模块也是拆卖模式，买下一整套完整的面捕动捕方案，需要<strong>990刀</strong>。</p>
<p>贫穷使我们相遇，看了看自己的钱包，我决定自己做一个。</p>
<p><strong>The point is how to cut costs!</strong></p>
<h3 id="part-b-implementing-a-simple-markless-facial-tracker">Part B – Implementing a Simple Markless Facial Tracker</h3>
<p>**前置理论知识：**阅读接下来的内容之前，你可能需要先了解一些机器学习中人脸关键点检测（Facial feature point detection）、计算机视觉中三维重构理论（3D Reconstruction）、计算机网络中套接字（Socket）以及计算机图形学中三维骨骼动画及绑定的基本原理（Binding &amp; Animation）的相关知识，本文不会对这部分原理作详细论述。<br>
**DCC软件与编程语言需求：**阅读接下来的内容之前，你可能需要先了解WebGL、JavaScript、3dsMax、MaxScript以及.Net（C#）的基本使用。</p>
<p>这一节我们来实现整个面捕工具的第一个部分——<strong>面部关键点捕捉工具（Tracker）</strong>。如下图所示是我们将要实现的完整面捕系统流程，下文我们将这个系统简称为MEPS（Markless facial tracking and Expression Projecting System），Tracker是整个系统从接收网络摄像头的视频流输入开始所要经过的第一个模块。</p>
<figure data-type="image" tabindex="9"><img src="http://localhost:4000/post-images/1674204596506.png" alt="" loading="lazy"></figure>
<center>本文将要实现的完整面捕系统MEPS，分为ML、Network、CG三大模块，</center>
<center>它们互相之间通过橙色的数据流节点联系在一起</center>
<br>
<p>这部分我们使用JavaScript基于WebGL实现，选择WebGL是因为其运行、部署都十分方便，只需要一个浏览器就可以运行我们的Tracker，即使更换了设备，也可以通过部署在服务器上的版本快速构建工作流，不需要像OpenGL或OpenCV等进行复杂的环境配置；同时，在浏览器端调用网络摄像头获取视频流也是非常简便的。</p>
<p>人脸关键点检测方法中具有里程碑式意义的有如下五种：<br>
（1）1995年，Cootes提出的ASM(Active Shape Model)；<br>
（2）1998年，还是Cootes提出的AAM(Active Appearance Model)；<br>
（3）2006年，Ristinacce提出的CLM（Constrained Local Model）算法；<br>
（4）2010年，Rollar提出的cascaded Regression算法。<br>
（5）2013年，Sun首次将CNN应用到人脸关键点检测，开创Deep Learning人脸关键点检测先河。</p>
<p>自2013年Sun等人在人脸关键点检测任务中使用CNN获得良好效果以来，众多学者将目光从传统方法转移到基于Deep Learning的方案，新方案不断被提出，不断突破检测精度的上限，例如从DCNN到Face++、从TCDCN到MTCNN等。</p>
<p>本文采用的是CVPR 2014上Vahid Kazemi提出的ERT（Ensemble of Regression Trees）算法[1]，该算法主要解决单幅图像的人脸对齐（Face Alignment）问题，通过建立一个级联的残差回归树（GBDT）从图像的像素灰度值稀疏子集中估计人脸关键点（landmarks）的位置。</p>
<p>训练过程中可以给网络喂一些公有数据库里的标注数据，比如CMU Multi-PIE人脸数据库、MUCT数据库、300-W(300 Faces in-the-Wild Challenge)混合数据库等。本文选用的全部是68个标记点的数据，因此训练完成后输出也是68个landmarks。当然也可以添加一些手动标注的自己的照片，这样在自己使用的时候捕捉精度会有所提升。这个Trick在ZJU CAD&amp;CG Lab一篇2014年的Paper: Real-time facial animation on mobile devices[2]中有所提及，在使用他们的移动端表情捕捉系统之前，他们会先为每个使用者拍摄60张手动标注数据的不同表情照片作为补充数据参与训练提高landmarks的对齐精度。</p>
<figure data-type="image" tabindex="10"><img src="http://localhost:4000/post-images/1674204654424.png" alt="" loading="lazy"></figure>
<center>针对一张输入图像，我们会得到左图这样的输出；</center>
<center>右图是输出的68个landmarks的编号，我们在后面的步骤中会用到</center>
<br>
<p>注意如果要在浏览器中调用网络摄像头获取实时视频流是需要将相关js脚本先部署到服务器上的，没有服务器也不要紧，这里可以通过nodejs、tomcat等快速搭建一个本地服务器，比如通过nodejs的http-server就可以，启动服务器后浏览器输入localhost:8080/your tracker name.html即可，非常简单。</p>
<figure data-type="image" tabindex="11"><img src="http://localhost:4000/post-images/1674205018545.png" alt="" loading="lazy"></figure>
<p>现在我们得到了一组68个landmarks，接下来如何基于这些信息将表情投射到我们的虚拟人脸上呢？这些landmarks是不能直接使用的，因为landmark的坐标是2D的，为了实现表情映射，我们有两条路可以选：</p>
<p>1、	继续沿着ML的路子走到黑，根据捕捉到的landmarks数据，分析出视频当前帧里演员的情绪（Facial Expression Recognition），例如喜、怒、哀、乐的百分比，得到多个范围为0-100的情绪状态数据，然后直接映射到我们目标三维角色的Blend Shape Target通道值上去；方法有很多，比如完全基于landmarks的方案和融合了Image与Landmarks的方法，具体方法的选择可以参考Shan L 等人的Deep Facial Expression Recognition: A Survey [4]这篇综述；</p>
<p>2、	借助计算机视觉中的三维重构方法，对landmarks的坐标做摄影机求反得到其在真实场景下的三维坐标，再结合我们之前文章中提出的表情重定向方法，将landmarks上携带的动画信息重定向到目标三维角色的骨骼上得到表情动画输出。</p>
<p>但实际实现中由于我们仅使用一个分辨率为640P的网络摄像头，精度非常有限，为了提高表情捕捉的准确性，MEPS在实际实现中采用的是混合方案。三维重构部分，通常计算机视觉中会采用双目摄像头方案，这样能够得到精确的求反结果；而如果仅用单目RGB相机，由于信息缺失太多，像素点的深度值是无法直接求解的。</p>
<figure data-type="image" tabindex="12"><img src="http://localhost:4000/post-images/1674205191969.png" alt="" loading="lazy"></figure>
<p>上式为单目针孔相机模型，其中<em>u</em>和<em>v</em>是视频流中时刻<em>t</em>下单帧图像中任意像素点<em>P</em>的屏幕空间二位坐标；(<em>x, y, z</em>)是该像素点在摄影机空间下的三维坐标，其中<em>z</em>为深度值。众所周知当仅给定一组坐标(<em>u, v</em>)的时候，我们是无法直接求解得到<em>z</em>值的。</p>
<p>但如果存在这么一种情况：摄像机的视角和距离地面的高度都是固定的，那么我们就能事先得到摄影机空间下地面的坐标，于是就可以在上面的相机模型中新增一条约束条件：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>x</mi><mo>+</mo><mi>B</mi><mi>y</mi><mo>+</mo><mi>C</mi><mi>z</mi><mo>+</mo><mi>D</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">Ax + By + Cz + D = 0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>其中A、B、C、D都是已知常数，于是我们就可以求解得到深度z了。这是在自动驾驶模拟中应用十分广泛的一种求解方法。在我们的MEPS系统中，摄像头的离地高度同样是不便的，演员面对屏幕，面部离地高度也是几乎不变的，因此我们就可以利用相似三角形原理对landmarks的坐标进行求反。</p>
<center><img src="../../post-images/1674205268786.png" width="400" /></center>
<p>那么如果既存在演员运动，摄影机也要运动的情况，怎么办呢？这种情况下要硬要求反也不是不可以，我们可以简单通过选取几个关键的landmarks，譬如通过两个眉尾的连线以及额头和鼻尖的连线，来非常rough地估计一个头部的相对旋转角度。下方是这个trick的伪代码描述：</p>
<pre><code name="codeblock">function FaceAngleEstimation(landmarks, imgDims) {
    const angle = (0, 0, 0);
    const radians = (a1, a2, b1, b2) => Math.atan2(b2 - a2, b1 - a1);

    if (!landmarks || landmarks.length !== 68) return angle;

    // roll is face lean left/right
    // comparing x,y of outside corners of leftEye and rightEye
    angle.roll = radians(landmarks[36].x, landmarks[36].y, landmarks[45].x, landmarks[45].y);

    // yaw is face turn left/right
    // comparing x distance of bottom of nose to left and right edge of face
    angle.pitch = radians(
        landmarks[30].x - landmarks[0].x, landmarks[27].y - landmarks[0].y, 
        landmarks[16].x - landmarks[30].x, landmarks[27].y - landmarks[16].y
    );

    // pitch is face move up/down
    // comparing size of the box around the face with top and bottom of detected landmarks
    const bottom = landmarks.reduce((prev, cur) => (prev < cur.y ? prev : cur.y), +INF);
    const top = landmarks.reduce((prev, cur) => (prev > cur.y ? prev : cur.y), -INF);
    angle.yaw = 10 * (imgDims.height / (top - bottom) / 1.45 - 1);

    return angle;
}</code></pre>
<p>这种方法求解得到的三维landmarks坐标并不会特别精确，但用在大范围运动的数值上比如上述头部的旋转角度的求解上，精度是完全足够的。再比如眼睛部位的眨眼判断，我们也完全可以不去求解其三维坐标。基于文献[5]中Soukupová 和Čech的相关研究我们可以得知，人眼在开合过程中左右眼角和上下眼皮的距离比值曲线会在眼睛闭合时产生一个明显的波谷，如下图：</p>
<center><img src="../../post-images/1674205392459.png" /></center>
<p>于是我们就可以利用这一特性，简单地基于上式求解眼睛的闭合百分比，不仅计算量小，精度也能够达标。<br>
除了landmarks的三维坐标重构，MEPS在处理动捕数据时还会综合考虑表情整体的情感表达，这部分输出的是一系列情感表现的百分比，范围为0-100。例如，我们可以简单地通过分析嘴角连线长度以及眼角连线长度之间的关系来得到当前演员表情的情绪状态是否是微笑，伪代码如下。</p>
<pre><code name="codeblock">// Smile Detection
setPoint(face.vertices, 48, p0); // mouth corner left
setPoint(face.vertices, 54, p1); // mouth corner right

var mouthWidth = calcDistance(p0, p1); 
setPoint(face.vertices, 39, p1); // left eye inner corner
setPoint(face.vertices, 42, p0); // right eye outer corner

var eyeDist = calcDistance(p0, p1);
var smileFactor = mouthWidth / eyeDist;

// 1.4 - neutral, 1.7 - smiling
smileFactor = clamp(smileFactor -1.4, 0, 1) / 0.3; </code></pre>
<p>至此我们就完成了Tracker模块的开发以及landmarks动捕数据的分析流程。</p>
<h3 id="part-c-implementing-dataflow-and-socket-bridge">Part C – Implementing Dataflow and Socket Bridge</h3>
<p>紧接着我们来完成数据流模块，这个部分的主要流程包括：<br>
1、	对Part B中已经完成分析的动捕数据输出进行编码；<br>
2、	实现一组一对多的Local Facial Tracking Data Server/Client，WebGL（JavaScript）端host一个server，不断广播编码后的动捕数据；<br>
3、	任意DCC软件或游戏引擎（下文我们以3dsMax为例）作为client，不断接收动捕数据并解码；</p>
<p>这里我们选用3dsMax作为接收端例子是因为在max中实现实时动捕相比在Unity等引擎中要更加困难，比如MaxScript并不支持WS Socket，以及不支持多线程等，这些都是需要克服的困难。</p>
<p>Part B中的动捕数据我们直接在Data Analyser模块中进行编码。Json和XML等格式放在这里显得体量有些太大了，由于是实时动捕应用，我们需要一个更轻量的数据存储格式来提升数据传输和编解码的速度。因此我们自订了MEPS中传输动捕数据使用的数据传输协议，这个协议的结构非常简单，如下所示：</p>
<blockquote>
<p><strong>[头部根骨骼朝向] , [18个3D landmarks坐标] , [50个2D landmarks坐标] , [12个情绪通道数据] , [其他可扩展数据] |</strong></p>
</blockquote>
<p>所有数据之间以符号’,’分隔，’|’为一帧数据的结束标记。完成编码后向我们的WS Server发送一条字符串消息即可：</p>
<figure data-type="image" tabindex="13"><img src="http://localhost:4000/post-images/1674205668177.png" alt="" loading="lazy"></figure>
<p>Server的实现比较常规，没什么好细说的。红框里是数据接收的部分，从Analyser模块每帧接收一次数据后再全局广播出去，这样就可以做到一次对接所有我们期望接收到动画的软件。Server我们同样用nodejs来host，注意端口号不要与之前Tracker的重合。</p>
<figure data-type="image" tabindex="14"><img src="http://localhost:4000/post-images/1674205681625.png" alt="" loading="lazy"></figure>
<p>需要注意的是由于我们接下来需要基于MaxScript实现client，而MaxScript是不支持WS Socket的，其仅支持TCP Socket，因此我们还需要实现一个Bridge，实现从WS Socket到TCP Socket的消息转发。</p>
<p>这部分我们就不去自己做实现了，还是基于nodejs搭一个从WS Socket到TCP Socket的转发代理，两行代码就能解决问题，同样需要注意端口号不要重复：</p>
<pre><code>//安装
npm install -g ws-to-tcp
//启动 from websocket端口 to TCP端口
ws-to-tcp --from 8000 --to 9000
</code></pre>
<p>至此我们就完成了数据流模块，现在不论是支持WS Socket还是TCP Socket的client都能够顺利接收到我们的面捕数据了（注意区分端口，不同类型的client要分别从两个端口接收数据）。</p>
<h3 id="part-d-facial-animation-retargeting-in-3dsmax">Part D –Facial Animation Retargeting in 3dsMax</h3>
<p>这一节我们实现3dsMax端的Reciver模块。MaxScript中我们首先需要解决的一大难题是：MaxScript不支持多线程，也就是说当MaxScript在解析Server发来的数据时，Max的主视图就会卡住，无法实现实时将表情动捕数据应用到角色模型上。</p>
<p>但从MaxScript开始支持与.Net交互后，事情出现了转机。.Net中有一个BackgroundWorker控件，在System.ComponentModel命名空间下，BackgroundWorker提供了执行异步操作（后台线程）的功能，它允许用户在一个单独的线程上执行多线程任务。当我们需要执行诸如下载等耗时任务时，又需要同时相应用户界面操作，此时就可以使用BackgroundWorker。</p>
<p>MaxScript中调用BackgroundWorker的流程和.Net中直接调用是相似的，只不过多了一些封装，我们需要先创建一个DotNetObject对象，然后添加EventHandler：</p>
<figure data-type="image" tabindex="15"><img src="http://localhost:4000/post-images/1674205739988.png" alt="" loading="lazy"></figure>
<p>让BackgroundWorker不断在后台线程中调用我们的解码器，然后将解码后的数据传递到虚拟角色上即可。这里我们可以额外定义一个Timer，用来控制调用解码器的频率。因为网络摄像头捕捉到的视频流的帧率是有限的，比如本文使用的640p网络摄像头捕捉到的视频流帧率在24-30fps左右，这和Max的视口刷新率是对不上的，如果频繁调用解码器，那么多数帧里解码器都是空调用的状态，无意义地浪费了性能，因此可以通过设置.Net 的Timer.interval来匹配client和server的帧率。</p>
<p>解码器的实现非常简单，使用正则表达式按照符号’,’划分数据即可。需要注意的是TCP Socket协议只管无脑发送数据，不关心每一帧数据的完整性，会产生**“半包”**和“**粘包”**问题，这与改进版的WS Socket不同。因此发送端我们不需要关心任何数据完整性问题，但接收端我们就必须手动维护一个数据池（Data Pool），每帧接收到的数据先手动判断一下结尾字符是不是’|’，如果不是，代表这一帧数据没有来得及发完，需要等待下一帧到来，拼接数据后再进行下一步操作；此外，即使结尾字符已经是’|’，我们也要过一遍这一个包里发来的数据，因为还可能存在“粘包”问题，也就是一帧或多帧的数据被压在了一个包里发送过来。如果在包体数据的中间发现了结束字符’|’，我们就需要手动做不同帧数据的切分。</p>
<p>解码完的数据直接应用到blend shape的通道值上或者直接基于我们之前文章中所述的表情重定向方法将其重定向到角色面部骨骼上即可。来看看现在的面捕表情捕捉效果吧：</p>
<figure data-type="image" tabindex="16"><img src="http://localhost:4000/post-images/1674208837278.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="http://localhost:4000/post-images/1674208846483.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="http://localhost:4000/post-images/1674208848921.png" alt="" loading="lazy"></figure>
<p>至此我们已经基本完成了MEPS的整套动捕流程，但现在直接使用MEPS做动捕时我们会发现两个问题：<br>
1、	面部关键点的移动会产生抖动，效果不好；<br>
2、	由于基于视频关键点的面部表情捕捉信息有限，不像基于深度相机做捕捉可以精确重建面部mesh，从而将表情动作过程中产生的面部皱纹也重定向到虚拟角色上，这就导致我们的虚拟角色生成的表情动画缺乏微表情细节，情感表达比较生硬。</p>
<p>下一节我们就来探讨如何进一步改善这些问题，让MEPS的面捕效果达到可用的产品级。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>i</mi><mi>p</mi><mi>A</mi><mi>n</mi><mi>i</mi><mi>m</mi><mrow><mo fence="true">(</mo><mi>t</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>m</mi><mi>i</mi><mi>x</mi><mrow><mo fence="true">(</mo><mrow><mi>v</mi><mi>A</mi><mrow><mo fence="true">(</mo><mi>t</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mtext>  </mtext><mi>a</mi><mi>A</mi><mrow><mo fence="true">(</mo><mi>t</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>c</mi><mrow><mo fence="true">(</mo><mi>t</mi><mo fence="true">)</mo></mrow></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">LipAnim\left( t \right) = mix\left( {vA\left( t \right),\;aA\left( t \right),c\left( t \right)} \right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">A</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Tool] RaindropFX for URP v1.0]]></title>
        <id>http://localhost:4000/post/tool-raindropfx-for-urp-100/</id>
        <link href="http://localhost:4000/post/tool-raindropfx-for-urp-100/">
        </link>
        <updated>2022-09-01T14:44:03.000Z</updated>
        <summary type="html"><![CDATA[<pre><code>RaindropFX 首个URP版本发布！
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code>RaindropFX 首个URP版本发布！
</code></pre>
<!-- more -->
<pre><code>Asset Store 传送门
</code></pre>
<p><a href="http://u3d.as/1M4D">&gt;&gt;&gt;Standard Version/标准渲染管线版&lt;&lt;&lt;</a><br>
<a href="http://u3d.as/1Un5">&gt;&gt;&gt;HDRP Version/高清渲染管线版&lt;&lt;&lt;</a><br>
<a href="https://u3d.as/2M2Z">&gt;&gt;&gt;URP Version/通用渲染管线版&lt;&lt;&lt;</a></p>
<pre><code>Forum 传送门
</code></pre>
<p><a href="https://forum.unity.com/threads/raindropfx-realistic-camera-lens-rain-effect.519068/#post-3402707">&gt;&gt;&gt;戳我&lt;&lt;&lt;</a></p>
<pre><code>Video 视频
</code></pre>
<p><a href="https://youtu.be/LFhNI72PlRk">[Youtube_RaindropFX_URP_First_Release]</a><br>
<a href="https://youtu.be/zxEuf7s79Ls">[Youtube_RaindropFX_URP_Quick_Tutorial]</a><br>
<a href="https://www.bilibili.com/video/BV12d4y1a772">[Bilibili_RaindropFX_URP_First_Release]</a></p>
<iframe src="//player.bilibili.com/player.html?aid=391859752&bvid=BV12d4y1a772&cid=940097016&page=1" width="700" height="350" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<script>
var ifr = document.getElementsByTagName("iframe")[0];
ifr.height=(ifr.offsetWidth/1.8).toString();
</script>
<pre><code>Intro 简介
</code></pre>
<p>Hey Guys! 😃<br>
RaindropFX Pro for URP is released!<br>
Hey 小可爱们！😃<br>
RaindropFX Pro for URP 发布啦!</p>
<p>Over the past year, I have received many inquiries about whether there will be a URP version RaindropFX and when it will be released. Sorry for the delay, But now it's done!<br>
One more thing, in the URP version, I replaced Gaussian Blur with Kawase Blur, it's quality is similar with Gaussian Blur but super fast (see the statistics below), so the performance of Raindrop solver will be greatly improved! 😉<br>
过去一年有很多用户问我RaindropFX 会不会推出URP版本，现在它来啦！<br>
此外，URP版本中的高斯模糊被替换为Kawase Blur，<br>
在渲染质量不变的情况下，速度能够获得4倍左右的提升！😉</p>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1674202330466.png" alt="" loading="lazy"></figure>
<pre><code>Screenshots 效果图
</code></pre>
<p><a href="../../post-images/1674202019207.png" data-lightbox="image-1" data-title="RaindropFX3.0"><img src="../../post-images/1674202019207.png" /></a></p>
<p><a href="../../post-images/1674202023130.png" data-lightbox="image-1" data-title="RaindropFX3.0"><img src="../../post-images/1674202023130.png" /></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Tool] RaindropFX for HDRP v3.0 - GPU Solver is Coming!]]></title>
        <id>http://localhost:4000/post/tool-raindropfx-for-hdrp-300/</id>
        <link href="http://localhost:4000/post/tool-raindropfx-for-hdrp-300/">
        </link>
        <updated>2022-08-15T14:39:43.000Z</updated>
        <summary type="html"><![CDATA[<pre><code>RaindropFX GPU解算器来啦！
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code>RaindropFX GPU解算器来啦！
</code></pre>
<!-- more -->
<pre><code>History 更改
</code></pre>
<blockquote>
<p>fixed: shader error in HDRP 10.2.2;<br>
修复：在HDRP10.2.2以上shader报错；<br>
added: half batches decreased(CPU solver);<br>
新增：CPU解算器Batches降低一半（性能提升最高达一倍）；<br>
added: dynamic wipe for object space version(CPU solver);<br>
新增：CPU解算器新增物体表面雨滴可擦除特性；<br>
added: raindrop painting(screen space, CPU solver);<br>
新增：CPU解算器增加屏幕空间交互式雨滴绘画功能；<br>
added: force LUT(affecting the flow direction of water droplets on object surface);<br>
新增：force LUT支持(用于影响物体表面雨滴的流动方向);<br>
added: assembly definition;<br>
新增：assembly definition;<br>
added: dynamic scaling of full screen raindrop texture(no longer need to preset the size at the beginning of the game);<br>
新增：动态全屏雨滴纹理（现在无需手动指定屏幕分辨率）；<br>
added: controllable fogging speed;<br>
新增：屏幕起雾速度控制；<br>
added: GPU screen space solver(beta);<br>
新增：屏幕空间GPU雨滴解算器（测试版）；<br>
added: GPU object space solver(beta);<br>
新增：物体表面空间GPU雨滴解算器（测试版）；<br>
added: fluids can interact with normal map(object space, GPU solver).<br>
新增：物体表面雨滴可与法线贴图交互.</p>
</blockquote>
<pre><code>Asset Store 传送门
</code></pre>
<p><a href="http://u3d.as/1M4D">&gt;&gt;&gt;Standard Version/标准渲染管线版&lt;&lt;&lt;</a><br>
<a href="http://u3d.as/1Un5">&gt;&gt;&gt;HDRP Version/高清渲染管线版&lt;&lt;&lt;</a></p>
<pre><code>Forum 传送门
</code></pre>
<p><a href="https://forum.unity.com/threads/raindropfx-realistic-camera-lens-rain-effect.519068/#post-3402707">&gt;&gt;&gt;戳我&lt;&lt;&lt;</a></p>
<pre><code>Video 视频
</code></pre>
<p><a href="https://youtu.be/M9g0TPl3ysw">[Youtube_3.0_NewFeatures]</a><br>
<a href="https://www.bilibili.com/video/BV1gz4y117DV">[Bilibili_RaindropFX_3.0]</a></p>
<iframe src="//player.bilibili.com/player.html?aid=587034100&bvid=BV1gz4y117DV&cid=307260707&page=1" width="700" height="350" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<script>
var ifr = document.getElementsByTagName("iframe")[0];
ifr.height=(ifr.offsetWidth/1.8).toString();
</script>
<pre><code>Intro 简介
</code></pre>
<p><strong>Compatibility/兼容性:</strong></p>
<blockquote>
<p>Compatible with HDRP 7.4.1+;<br>
支持高清渲染管线 7.4.1及以上版本;</p>
</blockquote>
<p><strong>Features/特性:</strong></p>
<blockquote>
<p>deeply integrated with HDRP Post Processing Stack;<br>
与HDRP屏幕后处理管线深度集成；<br>
post effect of the falling drops on the camera lens;<br>
屏幕雨滴动画后处理特效;<br>
raindrops animation based on physics;<br>
基于物理计算的水滴动画;<br>
dynamic wipe effect;<br>
交互式雨滴/屏幕雾擦除效果;<br>
wind turbulence support;<br>
支持添加风力以及紊乱风;<br>
radial wind for driving simulation;<br>
用于驾驶模拟的径向风；<br>
simulate colored liquids;<br>
模拟有色液体；<br>
choose CPU or GPU as the solver as you like, CPU solver offers better quality while GPU solver offers best performance;<br>
可选CPU或GPU作为雨滴解算器，CPU解算器提供最佳质量，GPU解算器提供极致性能；<br>
object space supported (add raindrop to object surface);<br>
支持将雨滴添加到物体表面；<br>
fluids can interact with normal map (GPU solver only);<br>
支持雨滴与法线贴图交互（仅GPU解算器支持此特性）；<br>
custom raindrop texture supported;<br>
支持自定义水滴形状;<br>
all source code is included, so you can customize it for yourself.<br>
包含所有源代码，您可以自行修改.</p>
</blockquote>
<pre><code>Screenshots 效果图
</code></pre>
<p><a href="../../post-images/1674118471981.png" data-lightbox="image-1" data-title="RaindropFX3.0"><img src="../../post-images/1674118471981.png" /></a></p>
<p><a href="../../post-images/1674118457290.png" data-lightbox="image-1" data-title="RaindropFX3.0"><img src="../../post-images/1674118457290.png" /></a></p>
<p><a href="../../post-images/1674118463356.png" data-lightbox="image-1" data-title="RaindropFX3.0"><img src="../../post-images/1674118463356.png" /></a></p>
<p><a href="../../post-images/1674118466679.png" data-lightbox="image-1" data-title="RaindropFX3.0"><img src="../../post-images/1674118466679.png" /></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Research] 实时可交互沙土模拟方法 - 渲染部分]]></title>
        <id>http://localhost:4000/post/realtime-sand-rendering/</id>
        <link href="http://localhost:4000/post/realtime-sand-rendering/">
        </link>
        <updated>2022-06-26T12:24:27.000Z</updated>
        <summary type="html"><![CDATA[<pre><code>本篇续前文介绍一种移动端真实感沙土渲染方法
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code>本篇续前文介绍一种移动端真实感沙土渲染方法
</code></pre>
<!-- more -->
<h2 id="real-time-interactive-sand-simulation-in-mobile-platform">Real-time Interactive Sand Simulation in Mobile Platform</h2>
<hr>
<h3 id="渲染部分shading-part">渲染部分/Shading Part</h3>
<p>做完物理解算，还需要做沙子的渲染部分。这里就不得不提《风之旅人》，在过去十年发行的众多独立游戏中，《风之旅人》几乎在各个方面都是卓越的典范。《风之旅人》可以说是“用沙子建造的”，它的沙子不仅仅是一个吸引眼球的视觉效果，而同时是与游戏核心玩法和整体体验息息相关的。<br>
没有沙子，就没有《风之旅人》。</p>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1674107191377.png" alt="" loading="lazy"></figure>
<center>《风之旅人》中的风沙渲染</center>
<br>
<h3 id="解刨风之旅人中的风沙渲染">解刨《风之旅人》中的风沙渲染</h3>
<p>正因为有《风之旅人》这样的珠玉在前，所以实现我们自己的沙子shader之前，我们先来解刨一下《风之旅人》的沙子shader是怎么实现的。<br>
thatgamecompany首席工程师John Edward曾经在GDC做过演讲：“Sand Rendering in journey”（传送门：https://www.youtube.com/watch?v=wt2yYnBRD3U&amp;ab_channel=GDC），本文对《风之旅人》的沙子shader解读大部分整理自上述课程。<br>
《风之旅人》中的沙子光照模型可以用下图概括：</p>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1674107240735.png" alt="" loading="lazy"></figure>
<center>《风之旅人》中的沙子渲染模型</center>
<p>由于沙子是由许多微小的晶粒组成的，因此不能简单地用光滑表面对其进行光照建模，在渲染过程中，我们需要考虑沙子本身的粒度。</p>
<h4 id="1-diffuse-part">1 - Diffuse Part</h4>
<p>漫反射部分是整个shader的实现流程中最简单的部分，直接用lambert模型即可：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo>=</mo><mn>4</mn><mo>∗</mo><mo>(</mo><mi>N</mi><mo>⊙</mo><mo>[</mo><mn>1.0</mn><mo separator="true">,</mo><mn>0.3</mn><mo separator="true">,</mo><mn>1.0</mn><mo>]</mo><mo>⋅</mo><mi>L</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">I = 4*(N \odot [1.0,0.3,1.0] \cdot L)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span></span></span></span></span></p>
<h4 id="2-rimlight-part">2 - RimLight Part</h4>
<p>《风之旅人》中有着大片连绵的沙丘，为了让玩家能够看清楚每一个沙丘的边界，John Edward在shader中添加了Rim Light，这部分可以用Fresnel实现：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo>=</mo><mrow><mo>(</mo><mn>1.0</mn><mo>−</mo><mi>N</mi><mo>⋅</mo><mi>V</mi><msup><mo>)</mo><mrow><mi>p</mi><mi>o</mi><mi>w</mi></mrow></msup></mrow><mo>∗</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">I = {(1.0 - N \cdot V)^{pow}} * strength
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span></span></p>
<p>现在沙丘看上去像这样，整体还比较光滑：</p>
<figure data-type="image" tabindex="3"><img src="http://localhost:4000/post-images/1674107509455.png" alt="" loading="lazy"></figure>
<h4 id="3-normal-part">3 - Normal Part</h4>
<p>为了让沙丘看上去不那么光滑，我们可以使用Normal Map通过扰动沙丘表面的法线方向来近似展现出沙子的粒度，但《风之旅人》里并没有使用传统意义上的Normal Map，而是使用一张Random Noise Texture来模拟沙子的法线，就像下图这样：</p>
<figure data-type="image" tabindex="4"><img src="http://localhost:4000/post-images/1674107602930.png" alt="" loading="lazy"></figure>
<p>每个像素的 R、G 和 B 分量存储沙子表面法向量的 X、Y 和 Z 分量。由于图片中存储的颜色分量范围为[0，1]，因此使用时我们需要将各个分量的范围重映射到[-1，1]：</p>
<pre><code name="codeblock">float3 SandNormal (float2 uv, float3 N) {
    float3 random = tex2D(_NoiseTex, uv).rgb;
    // Random direction: [0,1]->[-1,+1]
    float3 S = normalize(random * 2 - 1);
    return S;
}</code></pre>
<p>现在它看起来像这样，左侧是没有法线模拟的沙子，右侧是有法线模拟的沙子：</p>
<figure data-type="image" tabindex="5"><img src="http://localhost:4000/post-images/1674107825165.png" alt="" loading="lazy"></figure>
<h4 id="4-specular-part">4 - Specular Part</h4>
<p>高光部分，《风之旅人》做得比较独特。John Edward表示，他们团队在开发《风之旅人》时，希望游戏中的沙子感觉更像是流体，而不是固体。为了强化这种感觉，他们使用一种称之为Ocean Reflection的镜面反射，灵感来源于日落时在海洋或湖泊上看到的反射：</p>
<figure data-type="image" tabindex="6"><img src="http://localhost:4000/post-images/1674107856892.png" alt="" loading="lazy"></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo>=</mo><mrow><mo>(</mo><mi>N</mi><mo>⋅</mo><mover accent="true"><mi>H</mi><mo>^</mo></mover><msup><mo>)</mo><mrow><mi>p</mi><mi>o</mi><mi>w</mi></mrow></msup></mrow><mo>∗</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo separator="true">,</mo><mi>H</mi><mo>=</mo><mi>V</mi><mo>+</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">I = {(N \cdot \hat H)^{pow}} * strength,H = V + L
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.19677em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;">^</span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></span></p>
<pre><code name="codeblock">float3 OceanSpecular (float3 N, float3 L, float3 V) {
 	// Half direction
    float3 H = normalize(V + L);
    float NdotH = max(0, dot(N, H));
    float specular = pow(NdotH, _OceanSpecularPower) * _OceanSpecularStrength;
    return specular * _OceanSpecularColor;
}</code></pre>
<p>加上Ocean Specular 之后，现在整个画面看起来是这种感觉：</p>
<figure data-type="image" tabindex="7"><img src="http://localhost:4000/post-images/1674108700060.png" alt="" loading="lazy"></figure>
<h4 id="5-glitter-sandripple-part">5 - Glitter &amp; SandRipple Part</h4>
<p>最后两个部分是《风之旅人》中的沙子渲染最为独特的部分：模拟沙子的细碎闪光和沙子在风力作用下形成的波浪。<br>
细碎的闪光是沙丘表面一个不容忽视的特征，在真实沙丘上我们之所以可以看到闪光，是因为一些沙粒随机地将光线反射回我们的眼睛。</p>
<figure data-type="image" tabindex="8"><img src="http://localhost:4000/post-images/1674108732210.png" alt="" loading="lazy"></figure>
<p>但我们无法仅使用Specular来模拟闪光，因为几何体表面的法线变化通常太过连续，无法反射得到零碎且亮度大于1.0的光线。因此，《风之旅人》将闪光效果作为一个单独的着色阶段来实现，这部分借鉴了PBR模型中的微表面理论（Micro-facet Theory），它将沙丘表面视为由无数个微观镜子组成，每个镜子都有随机的方向。<br>
Normal Part中我们已经生成了一张Random Noise Texture，因此在这里我们就可以直接采样噪声纹理，将随机方向与构成沙子表面的每一粒沙子的微表面相关联。我们将这个噪声方向称为闪光方向，由于闪光方向是完全随机的，因此反射方向也将是完全随机而不连续的。最后结合Bloom屏幕后处理，我们就能够实现沙子表面细碎的闪光：</p>
<figure data-type="image" tabindex="9"><img src="http://localhost:4000/post-images/1674108761619.png" alt="" loading="lazy"></figure>
<pre><code name="codeblock">float3 GlitterSpecular (float2 uv, float3 N, float3 L, float3 V) {
    float3 G = normalize(tex2D(_NoiseTex, uv).rgb * 2 - 1);
    // Light that reflects on the glitter and hits the eye
    float3 R = reflect(L, G);
    float RdotV = max(0, dot(R, V));
    if (RdotV > _GlitterThreshold) return 0;
    else return (1 - RdotV) * _GlitterColor;
}</code></pre>
<p>最后是沙子表面波浪的部分，这是沙丘表面另一个不容忽视的特征。在风力作用下，沙粒之间由于摩擦力的作用而聚集在一起，形成波浪。这些波浪的变化不仅取决于沙丘的形状，还取决于风的方向和速度。大多数沙丘都仅在其一侧出现波纹：</p>
<figure data-type="image" tabindex="10"><img src="http://localhost:4000/post-images/1674108795482.png" alt="" loading="lazy"></figure>
<p>我们可以使用法线贴图来解决这个问题，但每次对沙丘做一些细微修改或创建新的沙丘时，都必须重新绘制法线纹理，这会显著减慢资产的生产速度。因此《风之旅人》中采用了一种更高效的解决方案：程序化（Procedural）波浪纹理。<br>
根据观察可以得出：波浪的形状会随着沙丘的倾斜度而变化，浅而平坦的沙丘波浪比较柔和；陡峭的沙丘则呈现出更深的波浪，因此我们可以先准备两张可平铺的法线贴图，一张用于较浅的沙丘波浪，一张则用于较深的沙丘波浪，然后根据每个沙丘的陡峭程度、风的方向来混合这两张贴图。<br>
这里采用的计算方式是：取沙丘表面法线与世界方向Y轴计算点积，计算结果越接近1，则两个向量之间的夹角越小，因此越陡峭；波浪的方向则根据风的方向与沙丘表面法线的点积来决定，但混合比例与陡度相反，因为通常沙丘逆风的一侧才会生成波浪。<br>
最后混合所有计算结果，沙丘看起来就是游戏中呈现的模样：</p>
<figure data-type="image" tabindex="11"><img src="http://localhost:4000/post-images/realtime-sand-rendering.png" alt="" loading="lazy"></figure>
<br>
<h3 id="实现我们自己的沙子渲染">实现我们自己的沙子渲染</h3>
<p>《风之旅人》是自由视角，而我们的沙子模拟是俯视角，因此在渲染流程上，我们可以将《风之旅人》的方法作为参考，但无法照搬，因为视角的不同会带来很多效果和实现方式上的差异。<br>
由于是俯视角，摄影机和光源角度都不会变化，因此显而易见的是我们首先可以删掉Ocean Specular部分的高光分量；其次，由于我们只做一小堆沙子，不像《风之旅人》中大规模的沙丘，小堆沙子不受风力影响，不会产生波纹，因此Ripple部分也可以排除。最后我们需要增加两个《风之旅人》的沙子Shader中没有的部分：杂质分量和Alpha分量，并对闪光分量的实现做一些修改，体现我们自己沙子Shader的特点。<br>
下面四张分别是我们的沙子shader中需要预先输入的漫反射纹理、杂质纹理、法线纹理以及Alpha纹理：</p>
<figure data-type="image" tabindex="12"><img src="http://localhost:4000/post-images/1674108931507.png" alt="" loading="lazy"></figure>
<h4 id="1-diffuse-part-impurity-part">1 - Diffuse Part &amp; Impurity Part</h4>
<p>漫反射部分比较简单，用一张可平铺的沙子纹理做采样就可以了。<br>
但如果仅用一张Color Texture，我们很快就会发现问题：《风之旅人》中的大片沙子都非常纯净，没有任何杂质，如果我们照搬到小沙堆的渲染上，就会发现一个严重的问题：沙子显得太纯太假了，不够写实，而且重复感严重。<br>
因此我们可以再正片叠底一张Impurity Texture到颜色部分，增加沙子的质感。需要注意的是Impurity Texture的平铺方式需要和Color Texture不同，减少重复感。</p>
<h4 id="2-normal-part">2 - Normal Part</h4>
<p>法线部分，同样是用一张可平铺的法线纹理，lambert模型做shading即可，丰富一下沙堆表面的明暗变化。这里一层法线就够了，不需要再混合做ripple了。</p>
<h4 id="3-glitter-part">3 - Glitter Part</h4>
<p>日常经验告诉我们，当扫除灰尘的时候，顺着扫除的方向会扬起烟尘。而沙子相比烟尘效果要更复杂一些，不仅有烟，还有细碎的闪光，这些闪光只在扬起烟雾的时候出现，不断闪烁，随后又消失，就像下图这样。</p>
<figure data-type="image" tabindex="13"><img src="http://localhost:4000/post-images/1674108992762.png" alt="" loading="lazy"></figure>
<p>为了让渲染结果更逼真，这部分闪光颗粒的模拟是不可或缺的，那么这部分怎么实现呢？上文模拟部分我们留了一个伏笔：解算纹理中我们留了一个G通道作为闪光分量，这个分量就是用在这里模拟闪光的。<br>
首先我们回顾一下《风之旅人》中沙子闪光的实现，《风之旅人》中使用一张RGB噪声纹理模拟随机的沙子表面法线变化，实现视角相关的闪光效果。但我们的摄影机是静止的，所以明显不能简单地把噪声作为法线方向。<br>
这里我们同样生成一张procedural noise texture，但和《风之旅人》中的噪声纹理不同，它是一张单通道纹理，我们实际只取用其灰度值。这个灰度值不作为法线，而是直接叠加到沙子的diffuse部分生成高光，当然叠加之前需要先让其通过一个高光滤波器，只保留其中亮度值大于一定阈值的像素点（下图左侧为灰度噪声图，右侧为闪光点反相）：</p>
<figure data-type="image" tabindex="14"><img src="http://localhost:4000/post-images/1674109013773.png" alt="" loading="lazy"></figure>
<p>然后把这部分作为亮度信息相加到diffuse上去即可生成闪光。但此时我们会面临两个问题：<br>
1、闪光点怎么闪烁？烟雾运动停止后闪光怎么熄灭？<br>
2、闪光点怎么跟随擦除方向和烟雾运动？</p>
<p>首先闪烁效果的部分，我们可以在生成noise texture时用时间作为种子，这样noise texture就会随时间不断变化，且与摄影机视角无关，就能够实现闪烁。<br>
运动和熄灭效果的实现就涉及到解算纹理的G通道：<br>
如果我们直接把闪光分量叠加到Thickness Buffer，会造成Thickness Buffer在模拟中变得不精确，甚至带来数值耗散；而如果直接叠加到diffuse，又无法产生运动。因此最好的办法就是让闪光分量单独作为一个通道来模拟，这样每次迭代过程中，不仅Thickness Buffer和Velocity Buffer随着迭代改变，闪光分量也随着速度场的改变而改变，就得到了闪光随着烟雾运动的效果。</p>
<p>其次，我们可以让G通道的亮度随解算时间t衰减：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>u</mi><mi>m</mi><mi>i</mi><mo>(</mo><mi>G</mi><mo separator="true">,</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>=</mo><mi>L</mi><mi>u</mi><mi>m</mi><mi>i</mi><mo>(</mo><mi>G</mi><mo separator="true">,</mo><mi>t</mi><mo>)</mo><mo>∗</mo><mrow><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><msup><mo>)</mo><mi>t</mi></msup></mrow></mrow><annotation encoding="application/x-tex">Lumi(G,t + 1) = Lumi(G,t) * {(1/2)^t}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.093556em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.843556em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这样就能够做到扬起烟雾一定时间后，闪光熄灭。</p>
<h4 id="4-alpha-part">4 - Alpha Part</h4>
<p>最后Alpha部分，这部分既描述物理模拟中的Thickness Buffer，也描述渲染过程中的沙堆Alpha。如上文所述，这部分分量可以由artist绘制得到，并在解算的过程中会不断发生改变，在渲染着色阶段，我们直接将其作为Alpha输出即可。<br>
这里需要注意的是，实际上Alpha Texture是可以合并到Color Texture的Alpha通道的，但Color Texture的RGB三个通道必须要保持四方连续，因为物理解算过程中Alpha通道的可见范围会不断发生变化，原来周围沙堆不可见的透明区域可能会在模拟途中变得可见，所以颜色通道必须是可平铺的。</p>
<h3 id="one-last-thing">One Last Thing</h3>
<p>至此所有的物理解算和渲染都已经完成了，但还有最后一步需要完成：如何判断沙子已经被玩家刷干净了？遍历每一个厚度场像素去计算剩余沙子的比例显然不合适，更何况Unity中RT的颜色值在CPU侧还无法直接读取。<br>
因为沙子总余量的统计不需要特别精确，所以这里我们可以借助mipmap来实现对整个厚度场总厚度的估计，每次玩家交互后一旦厚度场发生变化，我们就重新生成厚度场的mipmap，然后把RT转换为Texture2D：</p>
<pre><code name="codeblock">Texture2D ToTexture2D(RenderTexture rTex) {
RenderTexture.active = rTex;
    Texture2D tex = new Texture2D(rTex.width, rTex.height, TextureFormat, false);
    tex.ReadPixels(new Rect(0, 0, rTex.width, rTex.height), 0, 0); 
tex.Apply();
    return tex;
}</code></pre>
<p>最后取最后一层或倒数第二层mipmap level的中心像素颜色<em>c</em>即可，我们可以设定一个判定阈值<em>threshold</em>，<em>c</em> &lt; <em>threshold</em>就代表沙子已经刷干净了。</p>
<figure data-type="image" tabindex="15"><img src="http://localhost:4000/post-images/1674109174010.png" alt="" loading="lazy"></figure>
<p>最终的模拟中我们共用到：<br>
• 2张RenderTexture，大小512x512，格式R32G32B32A32_SFLOAT<br>
• 1张RGBA纹理（RGB通道为沙子漫反射颜色，A通道为沙子的厚度场）<br>
• 1张RGBA杂质纹理<br>
• 1张法线纹理</p>
<p>2张RT用于物理解算，其他纹理用于渲染。在配置2060 GPU的PC上物理解算部分GPU耗时0.21ms，渲染部分GPU耗时0.18ms，总耗时0.39ms；安卓端实机能以平均41.2FPS的帧率运行（测试机型：华为荣耀P20 Pro），对比2D MPM的21FPS，效率高出一倍。</p>
<p>最后，把所有的拼图拼到一起，DRSS就大功告成啦！来看看最终的效果吧：</p>
<figure data-type="image" tabindex="16"><img src="http://localhost:4000/post-images/1674109322891.gif" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="http://localhost:4000/post-images/1674109235286.gif" alt="" loading="lazy"></figure>
<h3 id="总结conclusion">总结/Conclusion</h3>
<p>本文简要介绍了一种实时移动端真实感沙土交互与渲染方法，能够模拟带厚度信息的俯视角干质沙土。实现DRSS的过程中最大的体会是：不存在现有解决方案的效果不一定就是无法实现的，根据实际需求尝试对做现有方法做一些优化改进，多走一步说不定问题就迎刃而解了。相比简单抽卡，以及《遇见逆水寒》中“擦玻璃”式的交互模式，沙土交互存在更多的不确定性，更能调动起玩家的兴趣，让玩家参与其中。</p>
<p>但DRSS目前也还存在几点不足，未来可以有如下改进方向：<br>
1、颜色和法线自始至终都是静态的，在解算过程中不会随着玩家交互而改变。这两个部分可以像闪光分量一样跟随Velocity Buffer做解算，让从颜色纹理中采样得到的颜色值也随着速度场运动，同时根据Thickness Buffer实时重新计算沙堆的法线方向，得到更加合理的明暗效果；<br>
2、沙土目前仅可以与玩家交互，后期还可以考虑加入与周围环境中物品的交互；<br>
3、如果把沙土覆盖的物品轮廓也考虑到沙土的法线中，做一个若隐若现的感觉，或许效果会更好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Research] 实时可交互沙土模拟方法 - 物理部分]]></title>
        <id>http://localhost:4000/post/realtime-interactive-sand-simulation/</id>
        <link href="http://localhost:4000/post/realtime-interactive-sand-simulation/">
        </link>
        <updated>2022-06-25T13:57:35.000Z</updated>
        <summary type="html"><![CDATA[<pre><code>本篇介绍一种移动端实时交互式沙土模拟方法
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code>本篇介绍一种移动端实时交互式沙土模拟方法
</code></pre>
<!-- more -->
<h2 id="real-time-interactive-sand-simulation-in-mobile-platform">Real-time Interactive Sand Simulation in Mobile Platform</h2>
<hr>
<h3 id="背景background">背景/Background</h3>
<p>移动端抽卡玩法已经屡见不鲜，表现形式多为点击、播片，玩家在一次次重复的交互过程中多多少少会产生疲倦感，于是我们决定在玩家交互上下点功夫，带来一些新鲜感。玩法设计上，我们希望是移动端二维俯视角，玩家通过交互刷开覆盖的沙土，发现新的收集品，让玩家在交互过程中体验小心翼翼的紧张感与仪式感，增加开奖时的快乐。</p>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1656212137313.png" alt="" loading="lazy"></figure>
<h3 id="技术挑战challenge">技术挑战/Challenge</h3>
<p>首先明确一下我们的效果目标：二维俯视角下的可交互沙土模拟，沙子渲染要有真实感，物理模拟要有体积感。玩家刷开沙子的过程中，沙子的运动要符合真实物理规律，能够被推开，也能够堆叠。当然最主要的是，在移动端，速度要快！</p>
<p>确定技术方案之前，先来看看现实世界里的沙子是怎么组成的。<br>
沙子的成分因产地而异，但其主要还是由矿物和微小的岩石碎片组成。岩石碎片是岩石经过侵蚀和风化而成，颗粒微小，这使得沙子的物理特性有点像流体，但又不能完全套用流体力学的计算方式来模拟其运动过程。</p>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1656212209091.png" alt="" loading="lazy"></figure>
<center>沙子的微观形态</center>
<br>
<p>我们先来看看市面上现有的游戏，下图是在沙子模拟效果上比较有代表性的两款作品，但它们明显在模拟规模上偏大，而且在体验上更注重于渲染效果，而非玩家交互，所以无法满足我们的需求。</p>
<figure data-type="image" tabindex="3"><img src="http://localhost:4000/post-images/1656212239158.png" alt="" loading="lazy"></figure>
<center>《风之旅人》和《刺客信条》中的沙子模拟</center>
<br>
<p>这两种模拟方法对于现在的新需求来说，都是不适用的，主要原因有以下两点：<br>
1、上面两款游戏的方法适用于沙漠场景中的大规模流沙模拟，是对沙子运动的一种宏观描述，而我们仅需要一小堆沙子；<br>
2、我们希望沙子是能够在有限的交互次数内被刷干净的，而不是永远“流”不完的。</p>
<p>要实现以上这些目标，就必须要有一个相对更加“物理”的模拟方法。图形学上实现真实沙子物理模拟的方法有很多，比如下图是基于物质点法（Material Point Method，MPM）使用Taichi实现的沙子物理模拟：</p>
<center><img src="../../post-images/1656211794583.gif" /></center>
<center>Sand simulation using MPM</center>
<br>
<p>MPM是一种将欧拉法（Eulerian）和拉格朗日法（Lagrangian）结合起来的计算方法，既避免了欧拉法要求解对流项的难题，又解决了拉格朗日法在处理大变形时的网格畸变和负体积问题，主要用于求解冲击、爆炸等高速、大变形问题，尤其是在沙子的动力学解算中非常常用。</p>
<figure data-type="image" tabindex="4"><img src="http://localhost:4000/post-images/1656212267111.png" alt="" loading="lazy"></figure>
<center>Iteration process of MPM</center>
<br>
<p>MPM中，沙粒的各种信息被保存在一个个离散的物质点上，然后：<br>
1、将物质点上的信息通过形函数 (Shape Function)映射到背景网格的节点上（Point to Grid，P2G）；<br>
2、通过传统的有限元法（Finite Element Method，FEM），计算单元刚度矩阵、荷载列阵，加入边界条件，求解节点位移、速度等信息；<br>
3、求解完后再通过Shape Function将单元节点上求解出来的信息映射回物质点上（更新物质点的位置、速度等；G2P，Grid to Point）；<br>
4、删除背景网格，返回第1步循环迭代。</p>
<p>MPM作为欧拉法和拉格朗日法之间的媒介，巧妙地在综合两种方法优点的同时又避免了两种方法自身的缺点，能够很好地模拟沙子的流动、扩散、堆叠现象，但它有个致命的问题，就是在移动端——会遇到性能瓶颈。<br>
这时我们会很自然地想到：既然是固定视角，直接做2D MPM效率会不会好呢？现实比较残酷，即使是2D MPM，在移动端单独跑沙子交互都依然帧率堪忧，就别提场景里还要加其他东西了。</p>
<figure data-type="image" tabindex="5"><img src="http://localhost:4000/post-images/1656212283147.png" alt="" loading="lazy"></figure>
<center>将MPM直接降维，在中端安卓机型上的性能表现</center>
<br>
<p>再看看shadertoy和youtube上大佬们基于其他解决方案的2D沙子模拟案例，都无一例外是正视图，没有俯视图的案例。而且模拟中直接丢弃了深度信息，沙子没有体积感，物理效果和渲染效果都不够写实。</p>
<figure data-type="image" tabindex="6"><img src="http://localhost:4000/post-images/1656212294959.png" alt="" loading="lazy"></figure>
<center>JSConf EU 2019上展示的web端沙子模拟案例</center>
<br>
<p>于是至此我们可以得出结论：现有方案里没有能够满足我们需求的，我们需要一个切实可行的新方案，且主要挑战在于要在满足效果需求的前提下做到在移动端落地。但究竟能不能找到这样一种方法以及能不能顺利落地，我们心里也没底，所以计划是先预研一版看看能否满足我们的效果目标，如果不行，就用简陋一些的“擦玻璃”方案作为保底。</p>
<center><img src="../../post-images/1656212318591.gif" /></center>
<center>类似《遇见逆水寒》锦屏绘春的“擦玻璃”式交互，是我们的保底方案</center>
<br>
<h3 id="模拟部分simulation-part">模拟部分/Simulation Part</h3>
<p>Ubisoft曾在SIGGRAPH 2020上发过一篇Paper：</p>
<figure data-type="image" tabindex="7"><img src="http://localhost:4000/post-images/1656212427503.png" alt="" loading="lazy"></figure>
<p>这篇Paper通过离线预计算的可分离泊松滤波器（Separable Poisson Filter）将基于欧拉法的流体模拟降维投影到纹理空间，在模拟质量几乎不变的情况下，实现了大幅性能提升：</p>
<figure data-type="image" tabindex="8"><img src="http://localhost:4000/post-images/1656212460959.png" alt="" loading="lazy"></figure>
<p>受其启发，沙子的物理模拟实际上也可以做降维与并行化的优化！由于是俯视角模拟，摄影机是不动的，所以首先我们可以把三维世界空间下的沙粒压缩到一张RGBA纹理上，x和z轴对应纹理空间u和v轴，y轴则压缩到纹理深度，这样就不会丢失沙堆的厚度信息。而且，当我们使用分辨率足够高的纹理进行采样的时候，实际上可以近似地把一个像素点看作一粒沙子：</p>
<figure data-type="image" tabindex="9"><img src="http://localhost:4000/post-images/1656212495417.png" alt="" loading="lazy"></figure>
<p>于是我们就不再需要做MPM中P2G和G2P的过程，直接基于像素点模拟即可。<br>
但需要注意的是为了模拟沙子的堆叠，让沙堆在交互过程中更有体积感，我们需要额外维护一个深度通道。由于降维后我们的网格是二维的，因此实际上这就像一个格子里面摞了一叠“小球”，而不是像MPM一样是一个三维网格，每一个网格里平铺多个小球！</p>
<figure data-type="image" tabindex="10"><img src="http://localhost:4000/post-images/1656212505203.png" alt="" loading="lazy"></figure>
<p>这个模拟方法我们就称之为DRSS（Dimension Reduction Sand Simulation），整个模拟流程就像这样：</p>
<center><img src="../../post-images/1656212518235.png" /></center>
<center>Iteration process of DRSS sand simulation</center>
<br>
<h4 id="1-preparing-thickness-buffer">1 - Preparing Thickness Buffer</h4>
<p>首先需要准备一个Thickness Buffer，就像这样：</p>
<center><img src="../../post-images/1656212909888.png" width="350" /></center>
<p>我们之前提到过，DRSS的模拟是带有深度信息的，Thickness Buffer就用于模拟沙堆的厚度（深度）。Thickness Buffer并不是程序化生成的，而是手动绘制的，实际模拟中，我们使用纹理的A通道来作为深度通道。用A通道作为Thickness Buffer的好处是，模拟完成之后，在着色阶段，我们可以直接将深度通道作为沙堆的Alpha值来进行渲染，无需进行其他的转换。<br>
而Thickness Buffer之所以要手动绘制，是为了方便artist在使用这套模拟系统的时候，能够方便地指定想要的沙堆的形状和厚度，Thickness Buffer可以简单地基于PS的干介质笔刷绘制得到。</p>
<h4 id="2-rendering-velocity-buffer">2 - Rendering Velocity Buffer</h4>
<p>然后需要准备一个Velocity Buffer，像这样：</p>
<figure data-type="image" tabindex="11"><img src="http://localhost:4000/post-images/1656212926996.gif" alt="" loading="lazy"></figure>
<p>Velocity Buffer的作用是描述每一个像素点位置沙子的运动方向，由于俯视角下不需要考虑重力，沙子在无交互情况下是静态的，所以实际上速度场只需要包含玩家交互部分的速度向量就可以了。<br>
速度向量可以是世界空间下的也可以是转到屏幕空间下的，但注意如果用世界空间速度，输出时不能对速度向量做clamp。</p>
<h4 id="3-drss-solver">3 - DRSS Solver</h4>
<h5 id="3-1-流动分量flow-component">3 - 1 - 流动分量（Flow Component）</h5>
<p>对沙子“流动”分量的描述，DRSS中使用半拉格朗日法（Semi-Lagrangian）实现：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>p</mi><mo>−</mo><mi>d</mi><mi>t</mi><mo>∗</mo><mi>v</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">p&#x27; = p - dt*vp
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">p</span></span></span></span></span></p>
<p>即对于每个位置<em>p</em>，根据位置<em>p</em>的速度<em>v<sub>p</sub></em>，反向寻找到位置<em>p’</em>，使用位置<em>p’</em> 的场的值来作为位置<em>p</em>的新场值。然后不断迭代，以此来描述沙子的运动：</p>
<center><img src="../../post-images/1656213134726.png" width="300" /></center>
<p>但由于我们要并行化地解算沙子的运动，所以不能直接使用上式求解，而是要将其改写成一个类似联合双边滤波（joint bilateral filter）的3x3卷积核形式来使用：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mrow><mi>K</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi></mrow></msub><mo>=</mo><mi>V</mi><mo>⋅</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">{F_{Kernel}} = V \cdot \left[ {\begin{array}{ccccccccccccccc}1&amp;1&amp;1\\1&amp;0&amp;1\\1&amp;1&amp;1\end{array}} \right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中<em>V</em>为速度场。于是可得：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>P</mi><mo>−</mo><mi>d</mi><mi>t</mi><mo>∗</mo><msub><mi>F</mi><mrow><mi>K</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P&#x27; = P - dt*{F_{Kernel}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.801892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中<em>P’<em>和</em>P</em>为位置矩阵。于是我们就可以得到沙子运动的流动分量，下图为不同速度下的流动分量模拟结果，交互物体从右侧开始运动，红线为停止线。可以看到速度较慢的时候，沙子运动距离短；速度快时，沙子运动距离更长，模拟结果符合物理规律。</p>
<center><img src="../../post-images/1656213238118.png" width="350" /></center>
<br>
<h5 id="3-2-扩散分量spread-component">3 - 2 - 扩散分量（Spread Component）</h5>
<p>由于沙子互相之间会发生碰撞挤压，因此除了单纯的流动之外，随着交互物体的移动，沙子还会在运动过程中发生扩散。<br>
扩散分量我们使用下式描述：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mi>L</mi><mi>q</mi><mo>⋅</mo><mi mathvariant="normal">D</mi><mo>(</mo><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi></mrow><mo>(</mo><mi>p</mi><mo>−</mo><mi>q</mi><mo separator="true">,</mo><msub><mover accent="true"><mi>v</mi><mo>^</mo></mover><mi>q</mi></msub><mo>)</mo><mo separator="true">,</mo><mi>θ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">S = Lq \cdot {\rm{D}}({\rm{Dot}}(p - q,{\hat v_q}),\theta )
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">D</span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">D</span><span class="mord mathrm">o</span><span class="mord mathrm">t</span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">^</span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中，<em>p</em>和<em>q</em>分别为当前像素点坐标和邻域像素点坐标；<em>L<sub>q</sub><em>为衰减因子，我们在下一部分堆叠分量中作详细介绍；Dot(<em>a</em>,<em>b</em>)为求向量</em>a</em>和<em>b</em>的点积；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mover accent="true"><mi>v</mi><mo>^</mo></mover><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">{\hat v_q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">^</span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>为规范化后的速度场在位置<em>q</em>处的速度向量；<em>θ</em>为扩散角度，由用户指定。</p>
<p>D(<em>x</em>,<em>θ</em>)为扩散函数，它是一个分段函数：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">D</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>θ</mi><mo>)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo>&gt;</mo><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">{\rm{D}}(x,\theta ) = \left\{ {\begin{array}{ccccccccccccccc}{1,x &gt; \theta }\\{0,otherwise}\end{array}} \right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">D</span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>扩散分量的模拟结果见下图，<em>θ</em>越大，随着交互物体的运动沙子会在流动的过程中扩散地越远；而当<em>θ</em>越接近0，则沙子只会在直线上流动。</p>
<table style="border: none;">
        <td style="border: none;"><img src="../../post-images/1673783239030.gif" /></td>
        <td style="border: none;"><img src="../../post-images/1673783243436.gif" /></td>
</table>
<center>Spread component, left:θ=0.05, right:θ=0.6</center>
<br>
<h5 id="3-3-堆叠迁移分量drift-component">3 - 3 - 堆叠&amp;迁移分量（Drift Component）</h5>
<p>虽然是降维模拟，但我们希望沙堆能具有体积感，单纯地基于像素点模拟单层沙子是无法体现出体积感的，因此堆叠分量就是基于我们最初设计的存储在A通道中的Thickness Buffer模拟厚度不匀的沙堆的体积感。</p>
<p>我们可以把厚度的模拟看作这样一个过程：每一个像素点上垂直堆叠了多层沙粒，每一次玩家交互，交互物体略过沙堆表面时，我们限制让其只能带动一定层数的沙粒，并且被带动的沙粒能够通过流动和扩散转移到其他像素格里，这样一来，就能够模拟沙堆的体积感了。</p>
<figure data-type="image" tabindex="12"><img src="http://localhost:4000/post-images/1673783744185.png" alt="" loading="lazy"></figure>
<p>实际迭代中，我们用下式描述这一过程：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>r</mi><mi>i</mi><mi>f</mi><mi>t</mi><mo>=</mo><munder><mo>∑</mo><mrow><mi>q</mi><mo>∈</mo><mi>S</mi></mrow></munder><mrow><mi>L</mi><mi>q</mi><mo>⋅</mo><mi mathvariant="normal">D</mi><mo>(</mo><mi>A</mi><mo separator="true">,</mo><mi>θ</mi><mo>)</mo><mo>⋅</mo><msub><mi>F</mi><mrow><mi>K</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi></mrow></msub><mo>⋅</mo><mi>T</mi><mi>q</mi></mrow></mrow><annotation encoding="application/x-tex">Drift = \sum\limits_{q \in S} {Lq \cdot {\rm{D}}(A,\theta ) \cdot {F_{Kernel}} \cdot Tq} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.480449em;vertical-align:-1.430444em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.430444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">D</span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi></mrow><mo>(</mo><mi>p</mi><mo>−</mo><mi>q</mi><mo separator="true">,</mo><msub><mover accent="true"><mi>v</mi><mo>^</mo></mover><mi>q</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">A = {\rm{Dot}}(p - q,{\hat v_q})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">D</span><span class="mord mathrm">o</span><span class="mord mathrm">t</span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;">^</span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">{T_q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>为像素<em>p</em>邻域<em>S</em>内的任意点<em>q</em>处的厚度值；衰减因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">{L_q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>由两个分量组成：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>q</mi><mo>=</mo><msub><mi mathvariant="normal">G</mi><mrow><mi>σ</mi><mi>S</mi></mrow></msub><mo>(</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>q</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>⋅</mo><mi mathvariant="normal">L</mi><mo>(</mo><msub><mi>T</mi><mi>p</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">Lq = {{\rm{G}}_{\sigma S}}(||p - q||) \cdot {\rm{L}}({T_p})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">G</span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">∣</span><span class="mord">∣</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">L</span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>第一个分量G为高斯核，用于限制堆叠分量在向周围像素转移过程中的移动距离；第二个分量为一个分段函数L(<em>x</em>)：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">L</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>l</mi><mi>o</mi><mi>s</mi><mi>s</mi><mo separator="true">,</mo><mi>x</mi><mo>≥</mo><mn>0.5</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1.0</mn><mo separator="true">,</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">{\rm{L}}(x) = \left\{ {\begin{array}{ccccccccccccccc}{loss,x \ge 0.5}\\{1.0,otherwise}\end{array}} \right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">L</span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><em>loss</em>是损失常量，由用户指定。<em>loss</em>为1.0时，沙子在转移过程中不会产生任何厚度损失，完全物理正确，但实际体验会发现这种情况下玩家需要反复擦拭一个位置才能把这个位置的沙子完全清理干净，看到下面覆盖的东西，玩起来很累，玩家体验不好。因此增加<em>loss</em>常量就能够让沙子在转移的过程中不断产生微小的厚度损失，让沙子更容易被擦干净：</p>
<figure data-type="image" tabindex="13"><img src="http://localhost:4000/post-images/1673784857921.gif" alt="" loading="lazy"></figure>
<h4 id="4-bring-all-the-components-together">4 - Bring all the components together!</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Static]Take-A-Shot]]></title>
        <id>http://localhost:4000/post/statictake-a-shot/</id>
        <link href="http://localhost:4000/post/statictake-a-shot/">
        </link>
        <updated>2021-08-29T14:58:30.000Z</updated>
        <summary type="html"><![CDATA[<pre><code>CG静帧
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code>CG静帧
</code></pre>
<!-- more -->
<p><a href="../../post-images/1630249216242.png" data-lightbox="image-1" data-title="Take A Shot"><img src="../../post-images/1630249216242.png" /></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Tool]Spline Mesher 2.0.0 (Pro)]]></title>
        <id>http://localhost:4000/post/toolspline-mesher-pro/</id>
        <link href="http://localhost:4000/post/toolspline-mesher-pro/">
        </link>
        <updated>2020-09-04T10:45:20.000Z</updated>
        <summary type="html"><![CDATA[<p>Unity3D程序化样条线建模工具SplineMesher专业版</p>
]]></summary>
        <content type="html"><![CDATA[<p>Unity3D程序化样条线建模工具SplineMesher专业版</p>
<!-- more -->
<blockquote>
<p>added: custom contour shape;<br>
新增: 自定义截面轮廓支持;<br>
Added: shape editor;<br>
新增: 二维图形编辑器；<br>
Added: improved gizmo;<br>
新增: 改进了样条线节点交互模式；<br>
Added: grow effect;<br>
新增: 样条线网格的生长参数；<br>
Added: automatic LOD;<br>
新增: 样条线网格自动LOD；<br>
Added: Least-Square Bezier Curve fitting;<br>
新增: 基于最小二乘法的贝塞尔曲线拟合；<br>
Added: mesh subdivide;<br>
新增: 样条线网格细分；<br>
Added: displacement threshold;<br>
新增: 置换曲线新增置换阈值参数；<br>
Added: tree generator (experimental);<br>
新增: 树木生成器（实验性版本）；<br>
Added: out-of-range displace curve type (extend displacement curve automatically);<br>
新增: 置换曲线out-of-range类型；<br>
Fixed: fixed a problem that failed to generate mesh when there were too many vertices. SplineMesher can now support up to 4 billion vertices.<br>
修复: 顶点数过多时生成畸形的网格。现在SplineMesher最大支持40亿顶点。</p>
</blockquote>
<pre><code>Asset Store 传送门
</code></pre>
<p><a href="http://u3d.as/218w">&gt;&gt;&gt;Pro Version/专业版&lt;&lt;&lt;</a></p>
<pre><code>Video 视频
</code></pre>
<p><a href="https://youtu.be/W1Pnr_W-UDg">[Youtube_2.0_NewFeatures]</a><br>
<a href="https://youtu.be/RFeAswWzg_k">[Youtube_1.0_HowToUse]</a></p>
<pre><code>Intro 简介
</code></pre>
<p><strong>Compatibility/兼容性:</strong></p>
<blockquote>
<p>support all platforms and rendering pipelines.<br>
支持所有平台与所有渲染管线.</p>
</blockquote>
<p><strong>Highlights/工具亮点:</strong></p>
<blockquote>
<p>easy to use: drag and drop the script to an empty gameobject to generate spline and tube mesh;<br>
简单易用: 拖拽脚本到空物体即可使用;<br>
mesh corner correction for very sharp spline corners;<br>
自动校正锐利转角处的管道网格顶点位置;<br>
support custom contour shape;<br>
支持自定义样条截面轮廓;<br>
different UV tile methods are offered to solve the texture stretching problem;<br>
支持三种不同的UV展开方式，能够从容应对各种情况下的贴图拉伸问题;<br>
adjust radius of each mesh segment by using custom displacement curve;<br>
支持使用自定义曲线调节管道每一节的粗细;<br>
grow parameter for planet growing animation;<br>
支持基于growth参数制作植物生长动画;<br>
automatic LOD (for Bezier Curve);<br>
样条线网格自动LOD（贝塞尔曲线）;<br>
support Least-Square Cubic Bezier Curve fitting;<br>
最小二乘法贝塞尔曲线拟合;<br>
spline mesh subdivide;<br>
支持样条线网格细分;<br>
edit spline and the tube mesh manually or using your code in no matter edit mode or game mode;<br>
可手动或通过代码编辑/生成样条线/网格，编辑器模式下与游戏模式下都可实时编辑;<br>
two types of spline are supported (corner and cubic bezier), and more types will be added in the future;<br>
现已支持两种类型的可编辑样条线 (折线类型与贝塞尔曲线类型), 将来将持续加入更多类型;<br>
tens of parameters (twist, rotate, grow, flip, cap, displacement threshold, etc.) to help you design any shape you like;<br>
大量可设置参数（扭曲、旋转、生长、翻转、封口、置换阈值，...），帮助您轻松设计创意外形;<br>
support up to 4 billion vertices.<br>
支持多达40亿个顶点.</p>
</blockquote>
<p><strong>Bonus content/附赠内容:</strong></p>
<blockquote>
<p>mathematical functions are in separate class so you can use them outside of SplineMesher, such as: Least-Square fitting, calculate normal and tangent for each vertices of your own 3D/2D splines, and so on;<br>
数学库单独封装，您可在本插件之外方便调用;<br>
a tree generator is included (experimental version);<br>
包含一个程序化树木生成器（实验性版本）;<br>
a 2D shape editor is included (for drawing custom contour shape or adding it to your own script);<br>
包含一个二维形状编辑器（用于绘制自定义样条截面轮廓，也可用于您的任意其他脚本）;<br>
all source code is included, so you can customize it for yourself.<br>
提供所有源码，您可自行查看与修改.</p>
</blockquote>
<pre><code>Screenshots 效果图
</code></pre>
<p><a href="../../post-images/1599221627262.png" data-lightbox="image-1" data-title="SplineMesherPro"><img src="../../post-images/1599221627262.png" /></a></p>
<p><a href="../../post-images/1599221654851.png" data-lightbox="image-1" data-title="SplineMesherPro"><img src="../../post-images/1599221654851.png" /></a></p>
<p><a href="../../post-images/1599221640901.png" data-lightbox="image-1" data-title="SplineMesherPro"><img src="../../post-images/1599221640901.png" /></a></p>
<p><a href="../../post-images/1599221644207.png" data-lightbox="image-1" data-title="SplineMesherPro"><img src="../../post-images/1599221644207.png" /></a></p>
<p><a href="../../post-images/1599221647812.png" data-lightbox="image-1" data-title="SplineMesherPro"><img src="../../post-images/1599221647812.png" /></a></p>
<p><a href="../../post-images/1599221651918.png" data-lightbox="image-1" data-title="SplineMesherPro"><img src="../../post-images/1599221651918.png" /></a></p>
<p><a href="../../post-images/1599221661001.png" data-lightbox="image-1" data-title="SplineMesherPro"><img src="../../post-images/1599221661001.png" /></a></p>
<p><a href="../../post-images/1599221718823.png" data-lightbox="image-1" data-title="SplineMesherPro"><img src="../../post-images/1599221718823.png" /></a></p>
<p><a href="../../post-images/1599221679472.png" data-lightbox="image-1" data-title="SplineMesherPro"><img src="../../post-images/1599221679472.png" /></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Tool]RaindropFX Pro update 2.5.0]]></title>
        <id>http://localhost:4000/post/toolraindropfx-pro-update-250/</id>
        <link href="http://localhost:4000/post/toolraindropfx-pro-update-250/">
        </link>
        <updated>2020-08-28T07:25:41.000Z</updated>
        <summary type="html"><![CDATA[<p>Unity3D 屏幕雨雾特效插件现已更新至2.5.0，新增HDRP支持</p>
]]></summary>
        <content type="html"><![CDATA[<p>Unity3D 屏幕雨雾特效插件现已更新至2.5.0，新增HDRP支持</p>
<!-- more -->
<blockquote>
<p>added: dyniamic wipe effect;<br>
新增: 动态擦除效果，可交互式擦除水滴及屏幕雾;<br>
added: droplet pixelization;<br>
新增: 水滴像素化，用于制作像素风游戏;<br>
added: screen rain mask;<br>
新增：屏幕雨滴遮罩，基于一张灰度图控制屏幕上水滴可见的部分（静态版本水滴擦除）.</p>
</blockquote>
<pre><code>Asset Store 传送门
</code></pre>
<p><a href="http://u3d.as/1M4D">&gt;&gt;&gt;Standard Version/标准渲染管线版&lt;&lt;&lt;</a><br>
<a href="http://u3d.as/1Un5">&gt;&gt;&gt;HDRP Version/高清渲染管线版&lt;&lt;&lt;</a></p>
<pre><code>Forum 传送门
</code></pre>
<p><a href="https://forum.unity.com/threads/raindropfx-realistic-camera-lens-rain-effect.519068/#post-3402707">&gt;&gt;&gt;戳我&lt;&lt;&lt;</a></p>
<pre><code>Video 视频
</code></pre>
<p><a href="https://youtu.be/M9g0TPl3ysw">[Youtube_2.5_NewFeatures]</a><br>
<a href="https://youtu.be/u-329KEE7Go">[Youtube_SetupWipeEffect_StandardPipe]</a><br>
<a href="https://youtu.be/n5AzNwzruZI">[Youtube_SetupWipeEffect_HDRP]</a></p>
<pre><code>Intro 简介
</code></pre>
<p><strong>Compatibility/兼容性:</strong></p>
<blockquote>
<p>SRP supported (HDRP 7.1.8+);<br>
支持可编程渲染管线SRP (高清渲染管线 7.1.8+);<br>
Both forward rendering and deferred rendering are supported;<br>
兼容前向渲染与缓冲渲染;<br>
Deeply integrated with post-processing stack;<br>
与Unity的后处理特效栈深度集成.</p>
</blockquote>
<p><strong>Features/特性:</strong></p>
<blockquote>
<p>deeply integrated with Post Processing Stack (v2);<br>
与PPV2深度集成；<br>
post effect of the falling drops on the camera lens;<br>
屏幕雨滴动画后处理特效;<br>
raindrops animation based on physics;<br>
基于物理计算的水滴动画;<br>
dynamic wipe effect;<br>
交互式雨滴/屏幕雾擦除效果;<br>
wind turbulence support;<br>
支持添加风力以及紊乱风;<br>
radial wind for driving simulation;<br>
用于驾驶模拟的径向风；<br>
simulate colored liquids;<br>
模拟有色液体；<br>
create screen fog effect and interactive with waterdrops naturally;<br>
支持创建屏幕雾气并能够与运动的水滴产生自然的动态交互效果;<br>
object space supported (add raindrop to object surface);<br>
新增物体表面空间版本（添加雨滴到物体表面）；<br>
batch image renderer (add raindrop to your video sequence);<br>
雨滴序列帧渲染器（可渲染雨滴动画到自定义序列帧）；<br>
custom raindrop texture supported;<br>
支持自定义水滴形状;<br>
all source code is included, so you can customize it for yourself.<br>
包含所有源代码，您可以自行修改.</p>
</blockquote>
<p><strong>Bonus post effects/额外附赠后处理特效:</strong></p>
<blockquote>
<p>Gaussian blur;<br>
高斯模糊;<br>
color levels;<br>
色阶;<br>
frosted glass effect;<br>
毛玻璃效果;<br>
split screen effect based on custom mask;<br>
多玩家分屏效果，支持自定义遮罩;<br>
screenshot captor;<br>
基于PPV2的截图工具；<br>
all the effects are integrated with Post Processing Stack (v2) and support sorting to get different results.<br>
以上后处理特效均已集成Unity后处理特效栈(v2)，支持排序产生不同的组合效果.</p>
</blockquote>
<pre><code>Screenshots 效果图
</code></pre>
<p><a href="../../post-images/1598600259922.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/1598600259922.png" /></a></p>
<p><a href="../../post-images/toolraindropfx-pro-update-250.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/toolraindropfx-pro-update-250.png" /></a></p>
<p><a href="../../post-images/1598600276688.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/1598600276688.png" /></a></p>
<p><a href="../../post-images/1598600280494.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/1598600280494.png" /></a></p>
<p><a href="../../post-images/1582782545107.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/1582782545107.png" /></a></p>
<p><a href="../../post-images/1582782583861.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/1582782583861.png" /></a></p>
<p><a href="../../post-images/1582782589936.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/1582782589936.png" /></a></p>
<p><a href="../../post-images/1582782593908.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/1582782593908.png" /></a></p>
<p><a href="../../post-images/1582782598973.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/1582782598973.png" /></a></p>
<p><a href="../../post-images/1582782606474.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/1582782606474.png" /></a></p>
<p><a href="../../post-images/1582782617460.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/1582782617460.png" /></a></p>
<p><a href="../../post-images/1582782621005.png" data-lightbox="image-1" data-title="RaindropFX2.5"><img src="../../post-images/1582782621005.png" /></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Tuto]Unity DOTS 原理解读&入门指南]]></title>
        <id>http://localhost:4000/post/tutounity-dots-ru-men-zhi-nan/</id>
        <link href="http://localhost:4000/post/tutounity-dots-ru-men-zhi-nan/">
        </link>
        <updated>2020-07-12T07:43:22.000Z</updated>
        <summary type="html"><![CDATA[<pre><code>什么是DOTS？Data-Oriented-Tech-Stack，多线程式数据导向型技术堆栈，Unity开发的终极解耦框架和运行效率提升利器。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code>什么是DOTS？Data-Oriented-Tech-Stack，多线程式数据导向型技术堆栈，Unity开发的终极解耦框架和运行效率提升利器。
</code></pre>
<!-- more -->
<br>
<h2 id="1-打个照面">1 打个照面</h2>
<p>DOTS, Data-Oriented-Tech-Stack，多线程式数据导向型技术堆栈，它由四个子系统组成：ECS、Job System、Burst Compiler以及Project Tiny。ECS和Job System在Unity 2018推出，Burst Compiler和Project Tiny则于2019年问世，Unite2019上DOTS概念被正式提出。</p>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1594539995455.jpg" alt="" loading="lazy"></figure>
<h4 id="dots能做什么">DOTS能做什么？</h4>
<p>DOTS是一套面向数据的高性能技术堆栈，一言以蔽之，同样的Unity项目，通过使用DOTS框架可以让项目得到接近十倍的性能提升，在移动平台上fps更高，电池消耗更低，发热更小。</p>
<h2 id="2-subsystem-overview">2 Subsystem overview</h2>
<h3 id="2-1-ecs">2-1 ECS</h3>
<p>ECS即Entity Component System的缩写，它是一套将数据和逻辑完全分离的数据驱动型框架。E\C\S分别代表实体（Entity）、组件（Component）与系统（System），它们之间存在如下关系：<br>
E: Entities contain Components<br>
C: Component contain data<br>
S: System contain behaviour<br>
也就是说，实体包含组件，组件携带数据，它们都是纯数据结构，系统则负责运行逻辑，操控数据，这种模式有两大优点：1、数据与逻辑的完全解耦；2、带来运行速度的提升。</p>
<h3 id="2-2-job-system">2-2 Job System</h3>
<p>Job System早先是Unity引擎的内部线程管理系统，但随着用户需求的日益增长，Unity开放了这部分系统让用户也可以无痛写出多线程并行处理的代码以提升产品性能，而无需自己实现复杂的线程池以维护各个线程的正常运行。Job System和Unity的Native Jobsystem整合在一起，用户编写的代码和Unity共享线程，这种合作形式避免了创建多于CPU核心数的线程会引起的CPU资源竞争。</p>
<h3 id="2-3-burst-compiler">2-3 Burst Compiler</h3>
<p>Burst Compiler是一个使用LLVM将IL / .NET字节码转换为高度优化的本机代码（也就是最适合目标平台的code）的编译器。<br>
Burst被设计来与Job System配合使用，当用户在完成基于Job System的代码后，便可以通过简单地增加“[BurstCompile(CompileSynchronously = true)]”声明来通过Burst Compiler对代码进行自动转换，整个过程对于用户来说是透明的，用户只需要关注自己的C#代码。</p>
<h3 id="2-4-project-tiny">2-4 Project Tiny</h3>
<p>Project Tiny是一种新的模块化Unity运行时和编辑器模式，旨在构建可以即时加载而无需安装的游戏和体验。它为开发人员提供了快速创建高质量2D即时游戏和可播放广告所需的工具，这些工具体积小，并可在各种移动设备上快速启动。<br>
需要注意的是，Project Tiny目前使用Typescript编写游戏逻辑，官方指出，在预览期间它将被C＃替换。使用C＃能够生成更小的代码大小和更好的性能，并提供改进的调试体验。<br>
<code>*由于Project Tiny尚在预览期间且主要面向移动端，本文不对其作详细介绍。</code></p>
<h2 id="3-dots为什么快">3 DOTS为什么快？</h2>
<p>为了解释明白为什么DOTS能够带来巨大的性能提升，我们需要先回头看看传统Unity的开发流程是怎样的：</p>
<ul>
<li>创建GameObject；</li>
<li>为GameObject添加各类所需组件，例如：Renderer、Collider、Custom Components, etc；</li>
<li>通过MonoBehavior将Component添加到对象，并在运行时查询和更改这些组件的状态。</li>
</ul>
<p>这种工作流被称为Classic Unity workflow，它在运行效率上有着先天不足，而这些效率问题来自于以下几个方面：</p>
<ul>
<li>数据和逻辑是高度耦合的，这导致代码的可复用性很低；</li>
<li>组件和组件之间需要来回引用，而组件又分布在堆内存的各处，CPU需要花费大量时间做寻址。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1594540253597.png" alt="" loading="lazy"></figure>
<center>Scattered memory references between gameobjects, their behaviors, and their components</center>
<br>
<h4 id="下面我们结合ecs架构看看究竟为什么这种数据结构会导致低效率">下面我们结合ECS架构看看究竟为什么这种数据结构会导致低效率？</h4>
<p>先来看看CPU的缓存结构：</p>
<center><img src="../../post-images/1594540264945.png" /></center>
<center>CPU<---->寄存器<---->CPU缓存<---->内存</center>
<br>
<p>可以看到CPU缓存是介于内存和寄存器之间的一个存储区域，此外它存储空间比内存小，比寄存器大。</p>
<h4 id="那么为什么现代cpu需要设置多级缓存呢">那么为什么现代CPU需要设置多级缓存呢？</h4>
<ul>
<li>CPU的运行频率太快了，而CPU访问内存的速度很慢，这样在处理器时钟周期内，CPU常常需要等待寄存器读取内存，浪费时间。</li>
<li>而CPU访问CPU缓存则速度快很多。为了缓解CPU和内存之间速度的不匹配问题，CPU缓存会预先存储好存在潜在可能性会被访问的内存数据，这些数据包括：
<ul>
<li>时间局部性数据：如果某个数据被访问，那么在不久的将来它很可能再次被访问。</li>
<li>空间局部性数据：如果某个数据被访问，那么与它相邻的数据很快也能被访问。</li>
<li>CPU多级缓存根据这两个特点，一般存储的是访问过的数据及其相邻数据。</li>
</ul>
</li>
</ul>
<p>CPU把待处理的数据或已处理的数据存入缓存中指定的地址，如果即将要处理的数据已经存在此地址了，就无需再到内存中寻找数据，此时就叫CPU缓存命中；反之，称CPU缓存未命中。因此，为了提高程序的运行效率，我们就要尽可能提高CPU缓存命中率，换句话说，就是要尽量让数据<strong>连续地存放在一起</strong>。</p>
<pre><code>*NOTE:
有人可能认为这样能最大程度利用CPU缓存：
把一个对象所有要用的数据（包括组件数据）都塞进一个类里，而没有任何用指针或引用的形式间接存储数据。

实际上这个想法是错误的，我们不能忽视一个问题：
CPU缓存的存储空间是有限的，于是我们希望CPU缓存存储的是经常使用的数据，而不是那些少用的数据。
这就引入了冷数据/热数据分割的概念了。

· 热数据：经常要使用的数据，一般可以作为可直接访问的成员变量存储。
· 冷数据：比较少用到的数据，一般以引用/指针来间接访问（即存储的是指针或者引用）。
</code></pre>
<p>这也就是ECS为何不采用OOP模式而改用Data Oriented Mode，OOP模式的主要的思想就是万物皆对象，调用的方式几乎都是以对象为基础，以模块化编程的带来优势的同时，也有他的负面效果：<strong>冗余数据过多，包袱过重</strong>。</p>
<p><img src="http://localhost:4000/post-images/1594540465938.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1594540472477.jpg" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1594540477189.jpg" alt="" loading="lazy"></p>
<p>举个例子，如上图，当我们需要大批量地以不同速度移动GameObject时，实际上我们仅仅需要其speed与transform两个属性，而其余变量其实都可以丢掉。OOP就是如此，在进行数据传输的时候（数据读取）总会带着一些无用的数据，不仅仅零零散散（传统方式的内存管理是离散式的），而且还占用空间（上文提到的CPU多级缓存），随着现在游戏的规模越来越大，摩尔定律的失效，单纯的提高主频达到好的计算效果变得越来越力不从心。<br>
而ECS中，所有所需数据量身定制，不存在多余数据，且确保所有的组件数据(Component Data)都紧密连接在一起，称为Archetype，这样就能确保存取内存资料时以最快的速度存取（也提高命中率）。例如，原有的Vector3换成了现在Float3，List换成了NativeArray，都是为了抛弃多余数据结构。</p>
<pre><code>*NOTE:
但要注意ECS也不是没有缺点，这种量身定制虽然带来了更多的选择和灵活性，但随之而来的是通用性的降低，因此ECS适用于规模庞大但个体之间差异不大的应用场景，当我们需要对群体中的每一个对象进行十分精细的控制时，ECS就显得力不从心了。
</code></pre>
<p>现在我们有了entity和component来高效地存储和读取数据，那么如何让数据流动起来呢？举个例子，如下图，当我们有很多的Bullet类型对象需要移动时，大多数程序员都会想到为它们编写一个管理器，例如一个Bullet Manager，然后维护一个Bullet列表，每帧更新这个列表中的所有Bullet的位置。没错，基于ECS处理这样一套框架再合适不过，bullet是entity，移动属性即为component，于是我们就可以将管理类bullet manager称作system，它管理所有bullet entity的移动。</p>
<figure data-type="image" tabindex="3"><img src="http://localhost:4000/post-images/1594540545567.jpg" alt="" loading="lazy"></figure>
<p>当然，我们不仅只能将这种架构用于单独一类对象的管理，如下图，我们可以为多类对象提供多个System进行统一管理，甚至也可以用一个system单独管理各类对象中的一类组件，在并行框架下将所有数据与处理逻辑完全解耦。</p>
<figure data-type="image" tabindex="4"><img src="http://localhost:4000/post-images/1594540557633.png" alt="" loading="lazy"></figure>
<p>ECS中我们通过改变数据组织结构和删减冗余数据的方式减少了CPU寻址时间，改善了系统性能。但终究我们会发现，这似乎只是“拆东墙补西墙”，寻址带来的性能瓶颈并非消失了，而只是性能热点被转移到了对数据的运算处理上，那我们还能不能再提升一些性能？<br>
我们知道，在Unity中虽然能够使用多线程，但其有非常大的限制，即线程只能进行与Unity无关的工作，例如数据运算等。与Unity引擎相关的操作几乎都会报错，例如用线程控制Transform就是一个无法实现的功能。在Unity中，所有与Unity相关的功能都只能够在主线程中完成，子线程是无法直接做到的。<br>
这里不得不提的是，除了多线程，Unity中还存在另一种类似的功能：协程（Coroutine）。什么是协程呢？协程跟多线程类似，也有类似异步的效果，但其不是真正的异步，所有的运算处理仍然在主线程上，只是它的切分粒度不是基于系统划分的时间片，而是基于我们编写的yield return，协程可以在任何时候被挂起，先继续往下执行主函数，然后到下一帧再来继续执行上一帧没执行完的协程函数。协程有很多优点，例如它的粒度相对多线程大很多，所以可以避免数据访问冲突；再例如，多线程中无法执行的与Unity直接相关的数据操作在协程中都畅通无阻。<br>
但协程的缺陷在于，虽然一个线程中可以有多个协程，但CPU的多个线程没有被完全利用起来，造成了资源浪费，如下图所示，“一核有难，七核围观”。于是到此就出现了一个两难的境地：多线程能够充分利用CPU资源但限制巨大，协程没有条条框框但却不能充分利用CPU资源，于是Job System应运而生。</p>
<figure data-type="image" tabindex="5"><img src="http://localhost:4000/post-images/1594540580991.jpg" alt="" loading="lazy"></figure>
<p>从这个角度来说，Job System和ECS密不可分，我们基于system来驱动数据，而这些数据块(Chunk)都有着一样的结构，相似的行为方式，于是性能提升方案呼之欲出：<strong>基于Job System通过多线程处理entity移动的方式，我们就将原本全部积压在主线程上的任务均匀分摊到CPU的各个线程上去执行，彻底榨干所有CPU性能</strong>。</p>
<h4 id="到此dots架构最核心的优化思想已经说完了但我们是不是忘了什么">到此，DOTS架构最核心的优化思想已经说完了，但我们是不是忘了什么？</h4>
<center><img src="../../post-images/1594540639974.gif" /></center>
<center>Burst Compiler : 我还没上车呢！</center>
<br>
<p>最后，别忘了DOTS中还有Burst Compiler，它能够基于LLVM将用户的Job System C#代码转换为高度优化的本机代码，因此，只需要在Job代码块前增加“[BurstCompile]”声明，我们就可以在不用做任何额外操作的前提下，白嫖10-30％的性能提升。</p>
<figure data-type="image" tabindex="6"><img src="http://localhost:4000/post-images/1594540718968.png" alt="" loading="lazy"></figure>
<center>Burst Compiler转换的汇编指令</center>
<br>
<h2 id="4-dots使用方式">4 DOTS使用方式</h2>
<h3 id="4-1-配置">4-1 配置</h3>
<p>DOTS的配置十分简单，现在所有的相关package都已经可以直接在package manager中自动下载配置，如下图，我们只需要下载如下几个包：</p>
<ul>
<li>entities</li>
<li>burst</li>
<li>jobs</li>
</ul>
<figure data-type="image" tabindex="7"><img src="http://localhost:4000/post-images/1594540927735.png" alt="" loading="lazy"></figure>
<p>其中需要注意的一点是，使用Burst Compiler之前我们需要做一点设置：<br>
<img src="http://localhost:4000/post-images/1594540800685.png" alt="" loading="lazy"></p>
<ul>
<li><strong>Use Burst Jobs</strong>: 启用Burst Compiler，所有带[Burst Compile]标识的Job代码块会被自动编译</li>
<li><strong>Burst Inspector</strong>: 查看BurstCompiler的所有编译结果</li>
<li><strong>Enable Burst Safety Checks</strong>: 选中后，使用集合容器（例如NativeArray<T>）的代码将启用安全性检查，尤其是Job System数据依赖性和容器索引超出范围检查</li>
<li><strong>Enable Burst Compilation</strong>: 所有带[Burst Compile]标识的Job代码块以及用户自定义委托（delegates）代码块会被自动编译</li>
<li><strong>Show Burst Timings</strong>: 选中后，每次编译时都会在编辑器中显示编译所用时间</li>
</ul>
<h3 id="4-2-使用">4-2 使用</h3>
<h4 id="说了半天如何实际使用dots呢">说了半天，如何实际使用DOTS呢？</h4>
<p>现在我们有四套框架可以开发Unity应用，如下：</p>
<pre><code>1、Classic System
2、Classic System + Job System
3、ECS + Job System
4、ECS + Job System + Burst Compiler
</code></pre>
<p>下面我们基于Unity官方的DOTS教程一一介绍并对比四套框架的性能，实验中使用的飞船模型如下：<br>
<img src="http://localhost:4000/post-images/1594540919858.png" alt="" loading="lazy"></p>
<p>实验环境为Intel® Core™ i7-8700K CPU + NVIDIA GeForce* GTX 1080 GPU，我们使用四套不同的系统绘制一个包含大量飞船运动的宇宙场景。</p>
<h4 id="4-2-1-classic-system">4-2-1 Classic System</h4>
<p>Classic System在每一帧检测用户输入并触发AddShips()方法，此方法在屏幕的左右两侧之间找到一个随机位置，然后在该位置生成一个飞船模型，并将飞船的方向设置为向下。</p>
<pre><code>void Update() {
    if (Input.GetKeyDown(&quot;space&quot;)) AddShips(enemyShipIncremement);
}
AddShips(int amount) {
    for (int i = 0; i &lt; amount; i++) {
        float xVal = Random.Range(leftBound, rightBound);
        float zVal = Random.Range(0f, 10f);
        Vector3 pos = new Vector3(xVal, 0f, zVal + topBound);
        Quaternion rot = Quaternion.Euler(0f, 180f, 0f);
        var obj = Instantiate(enemyShipPrefab, pos, rot) as GameObject;
    }
}
</code></pre>
<p>然后我们用另一个Movement脚本控制每一个飞船的运动，如下：</p>
<pre><code>using UnityEngine;
namespace Shooter.Classic {
    public class Movement : MonoBehaviour {
        void Update() {
            Vector3 pos = transform.position;
            pos += transform.forward * GameManager.GM.enemySpeed * Time.deltaTime;
            if (pos.z &lt; GameManager.GM.bottomBound) pos.z = GameManager.GM.topBound;
            transform.position = pos;
        }
    }
}
</code></pre>
<p>这套框架下，我们会发现当飞船数量达到16,500时，系统就已经有点吃不消了，帧率达到临界线30FPS：</p>
<figure data-type="image" tabindex="8"><img src="http://localhost:4000/post-images/1594541055741.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="http://localhost:4000/post-images/1594541060530.png" alt="" loading="lazy"></figure>
<h4 id="4-2-2-classic-system-job-system">4-2-2 Classic System + Job System</h4>
<p>现在我们使用Job System改写上一套框架中的Movement控制脚本，也就是使用多线程分批控制飞船的移动。改写后的MovementJob脚本如下，它实现了一个IJob接口，这意味这该脚本定义了一种task或job，能够批量管理、控制某一种data。<br>
为了进一步了解这个Job是如何组织的，让我们分解来看它使用的接口：<br>
<code>IJob | ParallelFor | Transform</code></p>
<ul>
<li><strong>IJob</strong>是所有IJob变体继承的基本接口；</li>
<li><strong>Parallel For Loop</strong>是一种并行模式，也就是一个典型的单线程For循环，task被根据索引范围将循环任务拆分成块，然后分发到不同的线程中进行操作；</li>
<li><strong>Transform</strong>则表示我们实现的Job中会包含TransformAccess属性，这将使得我们能够直接操作外部的所有Transform对象的引用。</li>
</ul>
<pre><code>using Unity.Jobs;
using UnityEngine;
using UnityEngine.Jobs;
namespace Shooter.JobSystem {
    [ComputeJobOptimization]
    public struct MovementJob : IJobParallelForTransform {
        public float moveSpeed;
        public float topBound;
        public float bottomBound;
        public float deltaTime;
        public void Execute(int index, TransformAccess transform) {
            Vector3 pos = transform.position;
            pos += moveSpeed * deltaTime * (transform.rotation * new Vector3(0f, 0f, 1f));
            if (pos.z &lt; bottomBound) pos.z = topBound;
            transform.position = pos;
        }
    }
}
</code></pre>
<p>接着我们创建一个<strong>GameManager</strong>管理Job与Transform数据的传递，其中我们会看到一些新的关键字：</p>
<ul>
<li><strong>TransformAccessArray</strong>是一个数据容器，它将保存对每艘船的Transform的引用。普通Transform类型数据不是线程安全的，因此这是一种方便的辅助类型，可以为游戏对象设置与移动相关的数据。</li>
<li><strong>MovementJob</strong>是我们刚刚创建的job结构的一个实例。这是我们将用于在作业系统中配置作业的内容。</li>
<li><strong>JobHandle</strong>是Job的唯一标识符，用于引用Job以执行各种操作，例如验证完成情况。</li>
<li></li>
</ul>
<pre><code>using UnityEngine;
using UnityEngine.Jobs;
namespace Shooter.JobSystem {
    public class GameManager : MonoBehaviour {
        // GameManager classic members
        TransformAccessArray transforms;
        MovementJob moveJob;
        JobHandle moveHandle;
        // GameManager code
        // ...
    }
}
</code></pre>
<p>最后，Update函数与AddShip函数则与Classic架构中使用的基本一致，但同样其中有一些新的关键字：</p>
<ul>
<li><strong>moveHandle.Complete()</strong> 保证主线程在计划的Job完成之前不会继续执行，一旦moveHandle.Complete()完成，则可以继续使用当前帧的新数据更新MovementJob，然后安排Job再次运行。虽然这是一个阻塞操作，但它可以防止在旧Job仍在执行时调度Job。此外，它还阻止我们在ships集合仍在迭代时添加新的ship。</li>
<li><strong>JobHandle.ScheduleBatchedJobs()</strong> 用于当所有的jobs都已经被设置好，准备就绪时，让当前等待的Jobs进入执行状态。</li>
</ul>
<pre><code>void Update() {
    moveHandle.Complete();
    if (Input.GetKeyDown(&quot;space&quot;)) AddShips(enemyShipIncremement);
    moveJob = new MovementJob() {
        moveSpeed = enemySpeed,
        topBound = topBound,
        bottomBound = bottomBound,
        deltaTime = Time.deltaTime
    };
    moveHandle = moveJob.Schedule(transforms);
    JobHandle.ScheduleBatchedJobs();
}
AddShips(int amount) {
    moveHandle.Complete();
    transforms.capacity = transforms.length + amount;
    for (int i = 0; i &lt; amount; i++) {
        float xVal = Random.Range(leftBound, rightBound);
        float zVal = Random.Range(0f, 10f);
        Vector3 pos = new Vector3(xVal, 0f, zVal + topBound);
        Quaternion rot = Quaternion.Euler(0f, 180f, 0f);
        var obj = Instantiate(enemyShipPrefab, pos, rot) as GameObject;
        transforms.Add(obj.transform);
    }
}
</code></pre>
<p>最后我们运行游戏，会看到现在在同等帧率下，同屏飞船数量被提升到了一倍左右：</p>
<figure data-type="image" tabindex="10"><img src="http://localhost:4000/post-images/1594541335387.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="http://localhost:4000/post-images/1594541339224.png" alt="" loading="lazy"></figure>
<h4 id="4-2-3-ecs-job-system">4-2-3 ECS + Job System</h4>
<p>接着我们再来看看将GameObject替换为entities后系统的性能表现。<br>
此时原本GameObject上所有的MonoBehaviour都需要被转换为Component，于是现在inspector上看到的属性可能看起来会有点奇怪，像下面这样：</p>
<figure data-type="image" tabindex="12"><img src="http://localhost:4000/post-images/1594541354870.png" alt="" loading="lazy"></figure>
<p>属性值的定义方式如下，我们不再像Classical开发方式一样继承MonoBehaviour，而是继承IComponentData，这样保证属性中没有冗余数据：</p>
<pre><code>using System;
using Unity.Entities;
namespace Shooter.ECS {
    [Serializable]
    public struct MoveSpeed : IComponentData {
        public float Value;
    }
    public class MoveSpeedComponent : ComponentDataWrapper&lt;MoveSpeed&gt; { }
}
</code></pre>
<p>GamaManager中需要修改的是属性数组的获取方式，因为我们的GameObject已经被转换为entity了，获取到的属性值存放在NativeArray中：</p>
<pre><code>using Unity.Collections;
using Unity.Entities;
using Unity.Mathematics;
using Unity.Transforms;
using UnityEngine;
namespace Shooter.ECS {
    public class GameManager : MonoBehaviour {
        EntityManager manager;
        void Start() {
            manager = World.Active.GetOrCreateManager&lt;EntityManager&gt;();
            AddShips(enemyShipCount);
        }
        void Update() {
            if (Input.GetKeyDown(&quot;space&quot;)) AddShips(enemyShipIncremement);
        }
        void AddShips(int amount) {
            NativeArray&lt;Entity&gt; entities = new NativeArray&lt;Entity&gt;(amount, Allocator.Temp);
            manager.Instantiate(enemyShipPrefab, entities);
            for (int i = 0; i &lt; amount; i++) {
                float xVal = Random.Range(leftBound, rightBound);
                float zVal = Random.Range(0f, 10f);
                manager.SetComponentData(entities[i], new Position { Value = new float3(xVal, 0f, topBound + zVal) });
                manager.SetComponentData(entities[i], new Rotation { Value = new quaternion(0, 1, 0, 0) });
                manager.SetComponentData(entities[i], new MoveSpeed { Value = enemySpeed });
            }
            entities.Dispose();
        }
    }
}
</code></pre>
<pre><code>using Unity.Collections;
using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Transforms;
using UnityEngine;
namespace Shooter.ECS {
    public class MovementSystem : JobComponentSystem {
        [ComputeJobOptimization]
        struct MovementJob : IJobProcessComponentData&lt;Position, Rotation, MoveSpeed&gt; {
            public float topBound;
            public float bottomBound;
            public float deltaTime;
            public void Execute(ref Position position, [ReadOnly] ref Rotation rotation, [ReadOnly] ref MoveSpeed speed) {
                float3 value = position.Value;
                value += deltaTime * speed.Value * math.forward(rotation.Value);
                if (value.z &lt; bottomBound) value.z = topBound;
                position.Value = value;
            }
        }
        protected override JobHandle OnUpdate(JobHandle inputDeps) {
            MovementJob moveJob = new MovementJob {
                topBound = GameManager.GM.topBound,
                bottomBound = GameManager.GM.bottomBound,
                deltaTime = Time.deltaTime
            };
            JobHandle moveHandle = moveJob.Schedule(this, 64, inputDeps);
            return moveHandle;
        }
    }
}
</code></pre>
<pre><code>using Unity.Collections;
using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Transforms;
using UnityEngine;

namespace Shooter.ECS {
    public class MovementSystem : JobComponentSystem {
        // ...
        // Movement Job
        // ...

        protected override JobHandle OnUpdate(JobHandle inputDeps) {
            MovementJob moveJob = new MovementJob
            {
                topBound = GameManager.GM.topBound,
                bottomBound = GameManager.GM.bottomBound,
                deltaTime = Time.deltaTime
            };
            JobHandle moveHandle = moveJob.Schedule(this, 64, inputDeps);
            return moveHandle;
        }
    }
}
</code></pre>
<p>修改完成，我们再次运行游戏，这时同等帧率下的同屏飞船数已经到了惊人的91,000个：</p>
<figure data-type="image" tabindex="13"><img src="http://localhost:4000/post-images/1594541444619.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="http://localhost:4000/post-images/1594541447575.png" alt="" loading="lazy"></figure>
<h4 id="4-2-4-ecs-job-system-burst-compiler">4-2-4 ECS + Job System + Burst Compiler</h4>
<p>最后别忘了我们还有Burst Compiler，Burst Compiler的使用极其简单，在Job代码块上添加[BurstCompile]，重新编译后运行游戏即可。最终我们可以看到，数量达到了150,000个，对比最初Classical开发方式下的16,500个，同屏飞船数提升了整整一个数量级。</p>
<figure data-type="image" tabindex="15"><img src="http://localhost:4000/post-images/1594541473891.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="http://localhost:4000/post-images/1594541481020.png" alt="" loading="lazy"></figure>
<h2 id="5-总结">5 总结</h2>
<p>最后我们可以再回过头对比一下实验中的数据，可以看到，结合DOTS中所有的优化技术，我们能够将一套完全相同系统的性能提升十倍以上，而最终成品则几乎没有品质上的差别。</p>
<table>
	<thead>
		<tr>
			<th>&nbsp;</th>
			<th><strong>Classic</strong></th>
			<th><strong>C# Job System + Classic</strong></th>
			<th><strong>C# Job System + Entity Component System (Burst Off)</strong></th>
			<th><strong>C# Job System + Entity Component System (Burst On)</strong></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><strong>Total Frame Time</strong></td>
			<td>~ 33 ms / frame</td>
			<td>~ 33 ms / frame</td>
			<td>~ 33 ms / frame</td>
			<td>~ 33 ms / frame</td>
		</tr>
		<tr>
			<td><strong># Objects on Screen</strong></td>
			<td>16,500</td>
			<td>28,000</td>
			<td>91,000</td>
			<td>150,000+</td>
		</tr>
		<tr>
			<td><strong>MovementJob Time Cost</strong></td>
			<td>~ 2.5 ms / frame</td>
			<td>~ 4 ms / frame</td>
			<td>~ 4 ms / frame</td>
			<td>~ &lt; 0.5 ms / frame</td>
		</tr>
		<tr>
			<td><strong>CPU Rendering Time Cost To Draw All Ships</strong></td>
			<td>10 ms / frame</td>
			<td>18.76 ms / frame</td>
			<td>18.92 job to calculate rendering matrices + 3 ms Rendering Commands = 21.92 ms / frame</td>
			<td>~ 4.5 ms job to calculate rendering matrices + 4.27 ms Rendering Commands = 8.77 ms / frame</td>
		</tr>
		<tr>
			<td><strong>Time GPU bound</strong></td>
			<td>~ 0 ms / frame</td>
			<td>~ 0 ms / frame</td>
			<td>~ 0 ms / frame</td>
			<td>~ 15.3 ms / frame</td>
		</tr>
	</tbody>
</table>
<p>Unity到2020已经变得越来越庞大臃肿，各类旧系统和新系统混杂在一起，让人不知如何选择，但使用任何新技术之前，我们都应该正确认识其能够带给我们的利弊，既不一味求变，也不故步自封，这样才能在面对问题时，做出最正确的选择。</p>
<figure data-type="image" tabindex="17"><img src="http://localhost:4000/post-images/1594550052757.jpg" alt="" loading="lazy"></figure>
<h3 id="参考文献">参考文献：</h3>
<p>[1] Get Started with the Unity* Entity Component System (ECS), C# Job System, and Burst Compiler，<br>
software.intel.com/content/www/us/en/develop/articles/get-started-with-the-unity-entity-component-system-ecs-c-sharp-job-system-and-burst-compiler.html<br>
[2] Burst User Guide,<br>
docs.unity3d.com/Packages/com.unity.burst@0.2/manual/index.html<br>
[3] Entity Component System Samples,<br>
github.com/Unity-Technologies/EntityComponentSystemSamples<br>
[4] Unity.Mathematics,<br>
docs.unity3d.com/Packages/com.unity.mathematics@1.1/manual/index.html<br>
[5] Entity Component System,<br>
docs.unity3d.com/Packages/com.unity.entities@0.11/manual/index.html<br>
[6] C# Job System,<br>
docs.unity3d.com/Manual/JobSystem.html</p>
]]></content>
    </entry>
</feed>